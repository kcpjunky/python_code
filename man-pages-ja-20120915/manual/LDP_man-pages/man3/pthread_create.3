.\" Copyright (c) 2008 Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PTHREAD_CREATE 3 2012\-03\-15 Linux "Linux Programmer's Manual"
.SH 名前
pthread_create \- 新しいスレッドを作成する
.SH 書式
.nf
\fB#include <pthread.h>\fP

\fBint pthread_create(pthread_t *\fP\fIthread\fP\fB, const pthread_attr_t *\fP\fIattr\fP\fB,\fP
\fB                   void *(*\fP\fIstart_routine\fP\fB) (void *), void *\fP\fIarg\fP\fB);\fP
.fi
.sp
\fI\-pthread\fP を付けてコンパイルとリンクを行う。
.SH 説明
\fBpthread_create\fP() 関数は、呼び出したプロセス内に新しいスレッドを作成する。
新しいスレッドの実行は、 \fIstart_routine\fP() を起動することで開始される。
\fIstart_routine\fP() は引き数を一つだけ取り、
\fIarg\fP が \fIstart_routine\fP() の引き数として渡される。

新しく作成されたスレッドは、以下のいずれかで終了する。
.IP * 2
スレッドが \fBpthread_exit\fP(3) を呼び出す。
\fBpthread_exit\fP(3) を呼び出す際には終了ステータス値を指定する。
この値は \fBpthread_join\fP(3) を呼び出した同じプロセス内の
別のスレッドで参照できる。
.IP *
スレッドが \fIstart_routine\fP() から返る。これは、
\fIreturn\fP 文に渡した値で \fBpthread_exit\fP(3) を呼び出すのと等価である。
.IP *
スレッドがキャンセルされる (\fBpthread_cancel\fP(3) 参照)。
.IP *
プロセス内のいずれかのスレッドで \fBexit\fP(3) が呼ばれるか、
メインスレッドで \fImain\fP() 内で return が実行される。
この場合は、プロセス内の全てのスレッドが終了される。
.PP
\fIattr\fP 引き数は \fIpthread_attr_t\fP 構造体へのポインタであり、
\fIpthread_attr_t\fP 構造体の内容を使用して、スレッド作成時に
新しいスレッドの属性が決定される。
この構造体は \fBpthread_attr_init\fP(3) や関連の関数を使って初期化される。
\fIattr\fP が NULL の場合、新しいスレッドはデフォルトの属性で作成される。

成功した場合は、 \fBpthread_create\fP() は返る前に新しいスレッドの ID を
\fIthread\fP が指すバッファに格納する。この ID は、これ以降に他の
pthreads 関数の呼び出しでスレッドを参照するのに使用される。

新しいスレッドは、スレッドを作成したスレッドのシグナルマスク
(\fBpthread_sigmask\fP(3) 参照) のコピーを継承する。
新しいスレッドの処理待ちシグナル (\fBsigpending\fP(2)) の集合は空となる。
新しいスレッドはスレッドを作成したスレッドの代替シグナルスタック
(\fBsigaltstack\fP(2)) を継承しない。

新しいスレッドは呼び出したスレッドの浮動小数点環境 (\fBfenv\fP(3))
を継承する。

.\" CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
新しいスレッドの CPU 時間時計の初期値は 0 である
(\fBpthread_getcpuclockid\fP(3) 参照)。
.SS "Linux 固有の詳細"
新しいスレッドは、呼び出したスレッドの
ケーパビリティセット (\fBcapabilities\fP(7) 参照) と
CPU affinity マスク (\fBsched_setaffinity\fP(2) 参照) の
コピーをを継承しない。
.SH 返り値
成功すると、 \fBpthread_create\fP() は 0 を返す。
エラーの場合は、エラー番号が返され、 \fI*thread\fP の内容は不定である。
.SH エラー
.TP 
\fBEAGAIN\fP
別のスレッドを作成するのに十分なリソースがないか、システムで設定された
スレッド数の上限に達していた。後者が起こるのは 2 つの場合がある。
一つは、実ユーザ ID 当たりのプロセス数の上限である、\fBRLIMIT_NPROC\fP
ソフトリソース上限 (\fBsetrlimit\fP(2) で設定できる) に達していた場合
である。もう一つはカーネルのシステム全体のスレッド数の上限である
\fI/proc/sys/kernel/threads\-max\fP が達していた場合である。
.TP 
\fBEINVAL\fP
\fIattr\fP で指定された設定が不正である。
.TP 
.\" FIXME . Test the following
\fBEPERM\fP
\fIattr\fP に指定されたスケジューリングポリシーとパラメータを
設定する許可がない。
.SH 準拠
POSIX.1\-2001.
.SH 注意
\fBpthread_create\fP() が \fI*thread\fP で返すスレッド ID についての
詳しい情報は \fBpthread_self\fP(3) を参照のこと。
リアルタイムスケジューリングポリシーが使用されない限り、
\fBpthread_create\fP() の呼び出し後に、
どのスレッドが\(em呼び出したスレッドか新しいスレッドか\(em
次に実行されるかは決まっていない。

スレッドは \fIjoin 可能\fPか \fIdetached (切り離された状態)\fP のどちらかに
することができる。スレッドが join 可能な場合、別のスレッドが
\fBpthread_join\fP(3) を使って終了したスレッドを待ち、終了ステータスを取得
することができる。終了した join 可能なスレッドは join された場合にのみ、
そのスレッドの最後に残ったリソースが解放されシステムに戻される。
detached 状態のスレッドが終了すると、そのスレッドのリソースは自動的に
システムに戻される。detached 状態のスレッドを join して、その終了
ステータスを取得することはできない。スレッドを detached 状態にするのは、
その終了ステータスをアプリケーションが気にする必要がないある種の
デーモン (daemon) スレッドでは有用である。
デフォルトでは、新しいスレッドは join 可能な状態で作成される。
(\fBpthread_attr_setdetachstate\fP(3) を使って) \fIattr\fP でスレッドが
detached 状態で作成されるように設定されていない限り、join 可能な状態で
作成される。

.\" FIXME . Perhaps some of the following detail should be in
.\" a future pthread_attr_setstacksize(3) page.
Linux/x86\-32 では、新しいスレッドのデフォルトのスタックサイズは 2MB で
ある。NPTL スレッド実装の下では、\fIプログラム開始時の\fP \fBRLIMIT_STACK\fP
ソフトリソース上限が"unlimited" 以外の場合、その値が新しいスレッドのデ
フォルトのスタックサイズとなる。
\fBpthread_attr_setstacksize\fP(3) を使って、スレッドを作成する際の
\fIattr\fP 引き数に明示的にスタックサイズ属性を設定することで、
デフォルト値以外のスタックサイズを得ることができる。
.SH バグ
廃止予定の LinuxThreads 実装では、プロセス内の各スレッドは異なる
プロセス ID を持つ。これは POSIX スレッドの規格に違反しており、
他の多くの標準非準拠の点の原因になっている。
\fBpthreads\fP(7) を参照のこと。
.SH 例
以下のプログラムは、 \fBpthread_create\fP() や
pthreads API の他のいろいろな関数の使用例を示している。

以下の実行例は、 NPTL スレッド実装が提供されているシステムでのもので、
スタックサイズがデフォルト値の "stack size" リソース上限で指定される値
になる。

.in +4n
.nf
$\fB ulimit \-s\fP
8192            # The stack size limit is 8 MB (0x80000 bytes)
$\fB ./a.out hola salut servus\fP
Thread 1: top of stack near 0xb7dd03b8; argv_string=hola
Thread 2: top of stack near 0xb75cf3b8; argv_string=salut
Thread 3: top of stack near 0xb6dce3b8; argv_string=servus
Joined with thread 1; returned value was HOLA
Joined with thread 2; returned value was SALUT
Joined with thread 3; returned value was SERVUS
.fi
.in

次の実行例では、プログラム内で、作成されるスレッドに対して
(\fBpthread_attr_setstacksize\fP(3) を使って1MB のスタックサイズを
明示的に設定している。

.in +4n
.nf
$\fB ./a.out \-s 0x100000 hola salut servus\fP
Thread 1: top of stack near 0xb7d723b8; argv_string=hola
Thread 2: top of stack near 0xb7c713b8; argv_string=salut
Thread 3: top of stack near 0xb7b703b8; argv_string=servus
Joined with thread 1; returned value was HOLA
Joined with thread 2; returned value was SALUT
Joined with thread 3; returned value was SERVUS
.fi
.in
.SS プログラムのソース
\&
.nf
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>

#define handle_error_en(en, msg) \e
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

#define handle_error(msg) \e
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

struct thread_info {    /* Used as argument to thread_start() */
    pthread_t thread_id;        /* ID returned by pthread_create() */
    int       thread_num;       /* Application\-defined thread # */
    char     *argv_string;      /* From command\-line argument */
};

/* Thread start function: display address near top of our stack,
   and return upper\-cased copy of argv_string */

static void *
thread_start(void *arg)
{
    struct thread_info *tinfo = (struct thread_info *) arg;
    char *uargv, *p;

    printf("Thread %d: top of stack near %p; argv_string=%s\en",
            tinfo\->thread_num, &p, tinfo\->argv_string);

    uargv = strdup(tinfo\->argv_string);
    if (uargv == NULL)
        handle_error("strdup");

    for (p = uargv; *p != \(aq\e0\(aq; p++)
        *p = toupper(*p);

    return uargv;
}

int
main(int argc, char *argv[])
{
    int s, tnum, opt, num_threads;
    struct thread_info *tinfo;
    pthread_attr_t attr;
    int stack_size;
    void *res;

    /* The "\-s" option specifies a stack size for our threads */

    stack_size = \-1;
    while ((opt = getopt(argc, argv, "s:")) != \-1) {
        switch (opt) {
        case \(aqs\(aq:
            stack_size = strtoul(optarg, NULL, 0);
            break;

        default:
            fprintf(stderr, "Usage: %s [\-s stack\-size] arg...\en",
                    argv[0]);
            exit(EXIT_FAILURE);
        }
    }

    num_threads = argc \- optind;

    /* Initialize thread creation attributes */

    s = pthread_attr_init(&attr);
    if (s != 0)
        handle_error_en(s, "pthread_attr_init");

    if (stack_size > 0) {
        s = pthread_attr_setstacksize(&attr, stack_size);
        if (s != 0)
            handle_error_en(s, "pthread_attr_setstacksize");
    }

    /* Allocate memory for pthread_create() arguments */

    tinfo = calloc(num_threads, sizeof(struct thread_info));
    if (tinfo == NULL)
        handle_error("calloc");

    /* Create one thread for each command\-line argument */

    for (tnum = 0; tnum < num_threads; tnum++) {
        tinfo[tnum].thread_num = tnum + 1;
        tinfo[tnum].argv_string = argv[optind + tnum];

        /* The pthread_create() call stores the thread ID into
           corresponding element of tinfo[] */

        s = pthread_create(&tinfo[tnum].thread_id, &attr,
                           &thread_start, &tinfo[tnum]);
        if (s != 0)
            handle_error_en(s, "pthread_create");
    }

    /* Destroy the thread attributes object, since it is no
       longer needed */

    s = pthread_attr_destroy(&attr);
    if (s != 0)
        handle_error_en(s, "pthread_attr_destroy");

    /* Now join with each thread, and display its returned value */

    for (tnum = 0; tnum < num_threads; tnum++) {
        s = pthread_join(tinfo[tnum].thread_id, &res);
        if (s != 0)
            handle_error_en(s, "pthread_join");

        printf("Joined with thread %d; returned value was %s\en",
                tinfo[tnum].thread_num, (char *) res);
        free(res);      /* Free memory allocated by thread */
    }

    free(tinfo);
    exit(EXIT_SUCCESS);
}
.fi
.SH 関連項目
\fBgetrlimit\fP(2), \fBpthread_attr_init\fP(3), \fBpthread_cancel\fP(3),
\fBpthread_detach\fP(3), \fBpthread_equal\fP(3), \fBpthread_exit\fP(3),
\fBpthread_getattr_np\fP(3), \fBpthread_join\fP(3), \fBpthread_self\fP(3),
\fBpthreads\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
