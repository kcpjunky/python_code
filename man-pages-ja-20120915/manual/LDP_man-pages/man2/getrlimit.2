.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt, March 28, 1992
.\" and Copyright (c) 2002, 2004, 2005, 2008, 2010 Michael Kerrisk
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 1993-07-23 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1996-01-13 by Arnt Gulbrandsen <agulbra@troll.no>
.\" Modified 1996-01-22 by aeb, following a remark by
.\"          Tigran Aivazian <tigran@sco.com>
.\" Modified 1996-04-14 by aeb, following a remark by
.\"          Robert Bihlmeyer <robbe@orcus.ping.at>
.\" Modified 1996-10-22 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 2001-05-04 by aeb, following a remark by
.\"          Håvard Lygre <hklygre@online.no>
.\" Modified 2001-04-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2002-06-13 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added note on nonstandard behavior when SIGCHLD is ignored.
.\" Modified 2002-07-09 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Enhanced descriptions of 'resource' values
.\" Modified 2003-11-28 by aeb, added RLIMIT_CORE
.\" Modified 2004-03-26 by aeb, added RLIMIT_AS
.\" Modified 2004-06-16 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on CAP_SYS_RESOURCE
.\"
.\" 2004-11-16 -- mtk: the getrlimit.2 page, which formally included
.\" coverage of getrusage(2), has been split, so that the latter
.\" is now covered in its own getrusage.2.
.\"
.\" Modified 2004-11-16, mtk: A few other minor changes
.\" Modified 2004-11-23, mtk
.\"	Added notes on RLIMIT_MEMLOCK, RLIMIT_NPROC, and RLIMIT_RSS
.\"		to "CONFORMING TO"
.\" Modified 2004-11-25, mtk
.\"	Rewrote discussion on RLIMIT_MEMLOCK to incorporate kernel
.\"		2.6.9 changes.
.\"	Added note on RLIMIT_CPU error in older kernels
.\" 2004-11-03, mtk, Added RLIMIT_SIGPENDING
.\" 2005-07-13, mtk, documented RLIMIT_MSGQUEUE limit.
.\" 2005-07-28, mtk, Added descriptions of RLIMIT_NICE and RLIMIT_RTPRIO
.\" 2008-05-07, mtk / Peter Zijlstra, Added description of RLIMIT_RTTIME
.\" 2010-11-06, mtk: Added documentation of prlimit()
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GETRLIMIT 2 2011\-09\-10 Linux "Linux Programmer's Manual"
.SH 名前
getrlimit, setrlimit, prlimit \- 資源の制限を取得/設定する
.SH 書式
\fB#include <sys/time.h>\fP
.br
\fB#include <sys/resource.h>\fP
.sp
\fBint getrlimit(int \fP\fIresource\fP\fB, struct rlimit *\fP\fIrlim\fP\fB);\fP
.br
\fBint setrlimit(int \fP\fIresource\fP\fB, const struct rlimit *\fP\fIrlim\fP\fB);\fP
.sp
\fBint prlimit(pid_t \fP\fIpid\fP\fB, int \fP\fIresource\fP\fB, const struct rlimit
*\fP\fInew_limit\fP\fB,\fP
.br
\fB struct rlimit *\fP\fIold_limit\fP\fB);\fP
.sp
.in -4n
glibc 向けの機能検査マクロの要件 (\fBfeature_test_macros\fP(7)  参照):
.in
.sp
\fBprlimit\fP(): _GNU_SOURCE && _FILE_OFFSET_BITS == 64
.SH 説明
\fBgetrlimit\fP() と \fBsetrlimit\fP() はそれぞれ資源 (resource) の制限
(limit) の設定と取得を行う。 各リソースには、それに対応するソフトリミッ
トとハードリミットがあり、 \fIrlimit\fP 構造体で定義される:
.PP
.in +4n
.nf
struct rlimit {
    rlim_t rlim_cur;  /* ソフトリミット */
    rlim_t rlim_max;  /* ハードリミット
                         (rlim_cur より小さくない) */
};

.fi
.in
ソフトリミットは、カーネルが対応するリソースに対して課す制限値である。 ハードリミットはソフトリミットの上限として働く。
特権を持たないプロセスは、ソフトリミットの値を 0 からハードリミットの範囲に設定することと、 ハードリミットを下げることのみができる
(一度下げたハードリミットは上げられない)。 特権プロセス (Linux では \fBCAP_SYS_RESOURCE\fP ケーパビリティ
(capability) を持つプロセス) は ソフトリミットとハードリミットを自由に変更できる。
.PP
値 \fBRLIM_INFINITY\fP はリソースに制限がないことを表す (この値は \fBgetrlimit\fP()  が返す構造体と
\fBsetrlimit\fP()  に渡す構造体の両方で使用される)。
.PP
\fIresource\fP 引き数は次のいずれか 1 つである。
.TP 
\fBRLIMIT_AS\fP
.\" since 2.0.27 / 2.1.12
プロセスの仮想メモリ (アドレス空間) の最大サイズ (バイト単位)。 この制限は \fBbrk\fP(2), \fBmmap\fP(2),
\fBmremap\fP(2)  の呼び出しに影響し、この制限を超えた場合は エラー \fBENOMEM\fP で失敗する。 また自動的なスタック拡張にも失敗する
(さらに \fBsigaltstack\fP(2)  を使った代替スタックを利用可能にしていなかった場合には、 \fBSIGSEGV\fP を生成してそのプロセスを
kill する)。 この値は \fIlong\fP 型なので、32 ビットの \fIlong\fP 型を持つマシンでは、 この制限は最大で 2 GiB
になるか、この資源が無制限になる。
.TP 
\fBRLIMIT_CORE\fP
\fIcore\fP ファイルの最大サイズ。 0 の場合、core ファイルは生成されない。 0 以外の場合、このサイズより大きいダンプは切り詰められる。
.TP 
\fBRLIMIT_CPU\fP
CPU 時間の上限 (秒数)。プロセスがソフトリミットに達した場合に、
\fBSIGXCPU\fP シグナルを送る。このシグナルに対するデフォルトの動作は、
プロセスの終了である。ただし、シグナルをキャッチして、ハンドラがメイン
プログラムに制御を返すこともできる。プロセスが CPU 時間を使い続けた
場合は、ハードリミットに達するまで 1 秒毎にプロセスに \fBSIGXCPU\fP を送り、
ハードリミットに達すると \fBSIGKILL\fP を送る。
(ソフトリミットを超過したときの動作は、 Linux における動作である。ソフ
トリミットを超えて CPU 時間を使い続けるプロセスの扱い方についての実装は
変化してきている。 このシグナルをキャッチする必要のある 移植性を考えた
アプリケーションでは、 最初に \fBSIGXCPU\fP を受け取った時点で正しく終了
すべきである。)
.TP 
\fBRLIMIT_DATA\fP
プロセスのデータセグメント (初期化されたデータ・初期化されていないデータ・ヒープ) の最大値。 このリミットは \fBbrk\fP(2)  と
\fBsbrk\fP(2)  の呼び出しに影響する。 これらの関数は、このリソースのソフトリミットに達すると、 エラー \fBENOMEM\fP で失敗する。
.TP 
\fBRLIMIT_FSIZE\fP
プロセスが作成できるファイルサイズの最大値。 このサイズを超えてファイルを拡張すると、 \fBSIGXFSZ\fP シグナルを送る。
デフォルトでは、このシグナルはプロセスを終了する。 プロセスをキャッチすることもできるが、 関連するシステムコール (\fBwrite\fP(2),
\fBtruncate\fP(2)  など) はエラー \fBEFBIG\fP で失敗する。
.TP 
\fBRLIMIT_LOCKS\fP (初期の Linux 2.4 のみ)
.\" to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
このプロセスが実行できる \fBflock\fP(2)  ロック数と \fBfcntl\fP(2)  リース数の合計値を制限する。
.TP 
\fBRLIMIT_MEMLOCK\fP
RAM 内にロックできるメモリの最大バイト数。 実際には、この制限はシステムページサイズの最も近い倍数に 切り捨てて丸められる。 この制限は
\fBmlock\fP(2), \fBmlockall\fP(2), \fBmmap\fP(2)  の \fBMAP_LOCKED\fP 操作に影響する。 Linux
2.6.9 以降では \fBshmctl\fP(2)  \fBSHM_LOCK\fP 操作にも影響する。 この操作は呼び出し元プロセスの実 (real) ユーザー
ID にロックされる 共有メモリセグメント (\fBshmget\fP(2)  を参照) の合計バイト数の最大値を設定する。 \fBshmctl\fP(2)
\fBSHM_LOCK\fP によるロックは、 \fBmlock\fP(2), \fBmlockall\fP(2), \fBmmap\fP(2)  の
\fBMAP_LOCKED\fP によって確立されるプロセス毎のメモリロックとは分けて数える。 1 つのプロセスはこの制限までのバイトをロックできる。
この制限には 2 つの種類がある。 2.6.9 より前の Linux カーネル では、
この制限は特権プロセスによってロックされるメモリの合計を制御していた。 Linux 2.6.9
以降では、特権プロセスがロックするメモリの合計に制限はなく、 代わりにこの制限は非特権プロセスがロックするメモリの合計に 適用されるようになった。
.TP 
\fBRLIMIT_MSGQUEUE\fP (Linux 2.6.8 以降)
呼び出し元プロセスの実ユーザー ID に対して、 POSIX メッセージキューのために確保できるバイト数の制限を指定する。 この制限は
\fBmq_open\fP(3)  に対して適用される。 ユーザが作成した各々のメッセージキューのバイト数は
以下の式により計算され、(そのキューが削除されるまでの間)  この制限の計算対象に含められる。
.nf

    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +
            attr.mq_maxmsg * attr.mq_msgsize

.fi
ここで \fIattr\fP は \fImq_attr\fP 構造体であり、 \fBmq_open\fP(3)  の第 4 引き数として指定される。

\fIsizeof(struct msg_msg *)\fP (Linux/i386 では 4 バイト) を含む最初の加数は、 ユーザーが長さ 0
のメッセージを無制限に作れないこと保証している (このようなメッセージであっても、 記録のためのオーバーヘッドでシステムメモリを消費する)。
.TP 
\fBRLIMIT_NICE\fP (Linux 2.6.12 以降, 下記の「バグ」の節も参照)
\fBsetpriority\fP(2)  や \fBnice\fP(2)  を使って引き上げられるプロセスの nice 値の上限を指定する。 nice
値の実際の上限は \fI20\ \-\ rlim_cur\fP で計算される (このような変な状況は、リソース制限値として負の数を指定できないため
発生する。通常、負の値は特別な意味を持っているからである。 例えば、通常は \fBRLIM_INFINITY\fP の値は \-1 である)。
.TP 
\fBRLIMIT_NOFILE\fP
このプロセスがオープンできるファイルディスクリプタ数の最大値より 1 大きい値を指定する。 (\fBopen\fP(2), \fBpipe\fP(2),
\fBdup\fP(2)  などにより) この上限を超えようとした場合、エラー \fBEMFILE\fP が発生する (歴史的に、BSD ではこの上限は
\fBRLIMIT_OFILE\fP という名前となっている)。
.TP 
\fBRLIMIT_NPROC\fP
呼び出したプロセスの実ユーザー ID で作成できる最大プロセス数 (より正確には Linux ではスレッド数)。 この上限に達すると、
\fBfork\fP(2)  はエラー \fBEAGAIN\fP で失敗する。
.TP 
\fBRLIMIT_RSS\fP
.\" As at kernel 2.6.12, this limit still does nothing in 2.6 though
.\" talk of making it do something has surfaced from time to time in LKML
.\"       -- MTK, Jul 05
プロセスの resident set (RAM 上に存在する仮想ページの数) の 上限を (ページ数で) 指定する。 この制限は 2.4.30
より前でしか影響がなく、 \fBmadvise\fP(2)  に \fBMADV_WILLNEED\fP を指定した関数コールにしか影響しない。
.TP 
\fBRLIMIT_RTPRIO\fP (Linux 2.6.12 以降, バグの節も参照)
\fBsched_setscheduler\fP(2)  や \fBsched_setparam\fP(2)
を使って設定できる、そのプロセスのリアルタイム優先度の上限を指定する。
.TP 
\fBRLIMIT_RTTIME\fP (Linux 2.6.25 以降)
リアルタイムスケジューリング方針でスケジューリングされるプロセスが ブロッキング型のシステムコールを呼び出さずに消費することのできる CPU
時間の合計についての上限を (マイクロ秒単位で) 指定する。 この上限の目的のため、プロセスがブロッキング型のシステムコールを 呼び出す度に、消費された
CPU 時間のカウントは 0 にリセットされる。 プロセスが CPU を使い続けようとしたが他のプロセスに置き換えられた (preempted)
場合や、そのプロセスのタイムスライスが満了した場合、 そのプロセスが \fBsched_yield\fP(2)  を呼び出した場合は、CPU
時間のカウントはリセットされない。

ソフトリミットに達すると、そのプロセスに \fBSIGXCPU\fP シグナルが送られる。そのプロセスがこのシグナルを捕捉するか 無視して、CPU
時間を消費し続けた場合には、 ハードリミットに達するまで 1 秒に 1 回 \fBSIGXCPU\fP が生成され続けることになる。
ハードリミットに達した時点で、そのプロセスには \fBSIGKILL\fP シグナルが送られる。

この上限を意図的に使用するのは、暴走したリアルタイムプロセスを 停止して、システムが動かなくなるのを避ける場合である。
.TP 
\fBRLIMIT_SIGPENDING\fP (Linux 2.6.8 以降)
.\" This replaces the /proc/sys/kernel/rtsig-max system-wide limit
.\" that was present in kernels <= 2.6.7.  MTK Dec 04
呼び出し元プロセスの実ユーザー ID に対して キューに入れられるシグナルの
数の制限を指定する。この制限をチェックするため、標準シグナルとリアルタ
イムシグナルの両方がカウントされる。しかし、この制限は \fBsigqueue\fP(3)
に対してしか強制されず、 \fBkill\fP(2) 使うことで、そのプロセスに対してま
だキューに入れられていない シグナルのインスタンスをキューに入れることが
できる。
.TP 
\fBRLIMIT_STACK\fP
プロセススタックの最大サイズをバイト単位で指定する。 この上限に達すると、 \fBSIGSEGV\fP シグナルが生成される。 このシグナルを扱うためには、
プロセスは代りのシグナルスタック (\fBsigaltstack\fP(2))  を使用しなければならない。

Linux 2.6.23 以降では、この制限はプロセスのコマンドライン引き数と環境変数
に使用される空間の合計サイズの上限の決定にも使用される。詳細については \fBexecve\fP(2)  を参照。
.SS prlimit()
.\" commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
.\" Author: Jiri Slaby <jslaby@suse.cz>
.\" Date:   Tue May 4 18:03:50 2010 +0200
The Linux\-specific \fBprlimit\fP()  system call combines and extends the
functionality of \fBsetrlimit\fP()  and \fBgetrlimit\fP().  It can be used to both
set and get the resource limits of an arbitrary process.

The \fIresource\fP argument has the same meaning as for \fBsetrlimit\fP()  and
\fBgetrlimit\fP().

If the \fInew_limit\fP argument is a not NULL, then the \fIrlimit\fP structure to
which it points is used to set new values for the soft and hard limits for
\fIresource\fP.  If the \fIold_limit\fP argument is a not NULL, then a successful
call to \fBprlimit\fP()  places the previous soft and hard limits for
\fIresource\fP in the \fIrlimit\fP structure pointed to by \fIold_limit\fP.

.\" FIXME this permission check is strange
.\" Asked about this on LKML, 7 Nov 2010
.\"     "Inconsistent credential checking in prlimit() syscall"
The \fIpid\fP argument specifies the ID of the process on which the call is to
operate.  If \fIpid\fP is 0, then the call applies to the calling process.  To
set or get the resources of a process other than itself, the caller must
have the \fBCAP_SYS_RESOURCE\fP capability, or the real, effective, and saved
set user IDs of the target process must match the real user ID of the caller
\fIand\fP the real, effective, and saved set group IDs of the target process
must match the real group ID of the caller.
.SH 返り値
成功した場合、これらのシステムコールは 0 を返す。
エラーの場合は \-1 が返され、 \fIerrno\fP が適切に設定される。
.SH エラー
.TP 
\fBEFAULT\fP
場所を指すポインタ引き数がアクセス可能なアドレス空間外を指している。
.TP 
\fBEINVAL\fP
\fIresource\fP で指定された値が有効でない。
または、 \fBsetrlimit\fP() や \fBprlimit\fP() で、
\fIrlim\->rlim_cur\fP が \fIrlim\->rlim_max\fP よりも大きかった。
.TP 
\fBEPERM\fP
特権のないプロセスがハードリミットを上げようとした。
これを行うためには \fBCAP_SYS_RESOURCE\fP ケーパビリティが必要である。
または、特権のないプロセスが \fBRLIMIT_NOFILE\fP ハードリミットを
現在のカーネルの最大値 (\fBNR_OPEN\fP) 以上に増やそうとした。
または、呼び出したプロセスが \fIpid\fP で指定されたプロセスのリミットを
設定する許可を持っていなかった。
.TP 
\fBESRCH\fP
Could not find a process with the ID specified in \fIpid\fP.
.SH バージョン
The \fBprlimit\fP()  system call is available since Linux 2.6.36.  Library
support is available since glibc 2.13.
.SH 準拠
\fBgetrlimit\fP(), \fBsetrlimit\fP(): SVr4, 4.3BSD, POSIX.1\-2001.
.br
\fBprlimit\fP(): Linux\-specific.

\fBRLIMIT_MEMLOCK\fP と \fBRLIMIT_NPROC\fP は BSD から派生し、
POSIX.1\-2001 には指定されていない。
これらは BSD 系と Linux に存在するが、他の実装は少ない。
\fBRLIMIT_RSS\fP は BSD から派生し、POSIX.1\-2001 には指定されていない。
それにも関わらず多くの実装で存在する。
\fBRLIMIT_MSGQUEUE\fP, \fBRLIMIT_NICE\fP, \fBRLIMIT_RTPRIO\fP, \fBRLIMIT_RTTIME\fP,
\fBRLIMIT_SIGPENDING\fP は Linux 固有のものである。
.SH 注意
\fBfork\fP(2)  で作成された作成された子プロセスは、 親プロセスのリソース制限を継承する。 \fBexecve\fP(2)
の前後でリソース制限は保存される。

シェルのリソース制限は、シェルの組み込みコマンドである \fIulimit\fP (\fBcsh\fP(1)  では \fIlimit )\fP
を使って設定することができる。 このシェルのリソース制限は、コマンドを実行してシェルが生成するプロセス に引き継がれる。

古いシステムでは、 \fBsetrlimit\fP()  と同様の目的を持つ関数 \fBvlimit\fP()  が提供されていた。 後方互換性のため、glibc
でも \fBvlimit\fP()  を提供している。 全ての新しいアプリケーションでは、 \fBsetrlimit\fP()  を使用すべきである。
.SH 例
The program below demonstrates the use of \fBprlimit\fP().
.PP
.nf
#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/resource.h>

#define errExit(msg) 	do { perror(msg); exit(EXIT_FAILURE); \e
                        } while (0)

int
main(int argc, char *argv[])
{
    struct rlimit old, new;
    struct rlimit *newp;
    pid_t pid;

    if (!(argc == 2 || argc == 4)) {
        fprintf(stderr, "Usage: %s <pid> [<new\-soft\-limit> "
                "<new\-hard\-limit>]\en", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid = atoi(argv[1]);        /* PID of target process */

    newp = NULL;
    if (argc == 4) {
        new.rlim_cur = atoi(argv[2]);
        new.rlim_max = atoi(argv[3]);
        newp = &new;
    }

    /* Set CPU time limit of target process; retrieve and display
       previous limit */

    if (prlimit(pid, RLIMIT_CPU, newp, &old) == \-1)
        errExit("prlimit\-1");
    printf("Previous limits: soft=%lld; hard=%lld\en",
            (long long) old.rlim_cur, (long long) old.rlim_max);

    /* Retrieve and display new CPU time limit */

    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == \-1)
        errExit("prlimit\-2");
    printf("New limits: soft=%lld; hard=%lld\en",
            (long long) old.rlim_cur, (long long) old.rlim_max);

    exit(EXIT_FAILURE);
}
.fi
.SH バグ
.\" FIXME prlimit() does not suffer
.\" https://bugzilla.kernel.org/show_bug.cgi?id=5042
.\" http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
以前の Linux カーネルでは、プロセスがソフトまたはハード \fBRLIMIT_CPU\fP リミットに達した場合に送られる \fBSIGXCPU\fP と
\fBSIGKILL\fP シグナルが、本来送られるべき時点の 1 (CPU) 秒後に送られてしまう。 これはカーネル 2.6.8 で修正された。

.\" see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
2.6.17 より前の 2.6.x カーネルでは、 \fBRLIMIT_CPU\fP リミットが 0 の場合、 (\fBRLIM_INFINITY\fP
と同じように) 「制限なし」と間違って解釈されていた。 Linux 2.6.17 以降では、リミットを 0 に設定した場合にも
効果を持つようになっているが、実際にはリミットの値は 1 秒となる。

カーネル 2.6.12 には、 \fBRLIMIT_RTPRIO\fP が動作しないというバグがある。この問題はカーネル 2.6.13 で修正されている。

.\" see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
カーネル 2.6.12 では、 \fBgetpriority\fP(2)  と \fBRLIMIT_NICE\fP
が返す優先度の範囲が一つずれていた。このため、nice 値の実際の上限が \fI19\ \-\ rlim_cur\fP
になってしまうという影響があった。これはカーネル 2.6.13 で修正された。

2.4.22 より前のカーネルでは、 \fIrlim\->rlim_cur\fP が \fIrlim\->rlim_max\fP より大きかった場合、
\fBsetrlimit\fP()  での \fBEINVAL\fP エラーを検出できない。
.SH 関連項目
\fBdup\fP(2), \fBfcntl\fP(2), \fBfork\fP(2), \fBgetrusage\fP(2), \fBmlock\fP(2),
\fBmmap\fP(2), \fBopen\fP(2), \fBquotactl\fP(2), \fBsbrk\fP(2), \fBshmctl\fP(2),
\fBmalloc\fP(3), \fBsigqueue\fP(3), \fBulimit\fP(3), \fBcore\fP(5), \fBcapabilities\fP(7),
\fBsignal\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.40 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
