.\" Copyright 2002 Walter Harms <walter.harms@informatik.uni-oldenburg.de>
.\" and Andries Brouwer <aeb@cwi.nl>.
.\" Distributed under GPL.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH TTY_IOCTL 4 2008\-10\-29 Linux "Linux Programmer's Manual"
.SH 名前
tty_ioctl \- 端末とシリアルラインの ioctl (入出力制御)
.SH 書式
\fB#include <termios.h>\fP
.sp
\fBint ioctl(int \fP\fIfd\fP\fB, int \fP\fIcmd\fP\fB, ...);\fP
.SH 説明
端末とシリアルポートについての \fBioctl\fP(2)  コールは、多くのコマンド引き数を受け付ける。 多くがいろいろな型の 3
番目の引き数を必要とする。 ここでは \fIargp\fP または \fIarg\fP と呼ぶ。
.LP
\fIioctl\fP を使用すると移植性のないプログラムになる。 可能な場合は、 \fBtermios\fP(3)  に記述されている POSIX
インタフェースを使うこと。
.SS 端末属性の取得と設定
.TP 
\fBTCGETS	struct termios *\fP\fIargp\fP
\fItcgetattr(fd, argp)\fP と同じ。
.br
現在のシリアルポートの設定を取得する。
.TP 
\fBTCSETS	const struct termios *\fP\fIargp\fP
\fItcsetattr(fd, TCSANOW, argp)\fP と同じ。
.br
現在のシリアルポートの設定を変更する。
.TP 
\fBTCSETSW	const struct termios *\fP\fIargp\fP
\fItcsetattr(fd, TCSADRAIN, argp)\fP と同じ。
.br
排出 (drain) を行うための出力バッファの使用を許可し、 現在のシリアルポートの設定を変更する。
.TP 
\fBTCSETSF	const struct termios *\fP\fIargp\fP
\fItcsetattr(fd, TCSAFLUSH, argp)\fP と同じ。
.br
排出 (drain) を行うための出力バッファの使用を許可し、 処理していない入力を破棄して、 現在のシリアルポートの設定を変更する。
.LP
以下の 4 つの ioctl は \fBTCGETS\fP, \fBTCSETS\fP, \fBTCSETSW\fP, \fBTCSETSF\fP と似ている。 ただし、
\fIstruct termios *\fP の代わりに \fIstruct termio *\fP を取る。
.TP 
\fBTCGETA	struct termio *\fP\fIargp\fP
.TP 
\fBTCSETA	const struct termio *\fP\fIargp\fP
.TP 
\fBTCSETAW	const struct termio *\fP\fIargp\fP
.TP 
\fBTCSETAF	const struct termio *\fP\fIargp\fP
.SS "termios 構造体のロック"
端末の \fItermios\fP 構造体はロックすることが可能である。 このロック自体は \fItermios\fP 構造体であり、 0
でないビットまたはフィールドはロックされた値を示す。
.TP 
\fBTIOCGLCKTRMIOS	struct termios *\fP\fIargp\fP
端末の \fItermios\fP 構造体のロック状態を取得する。
.TP 
\fBTIOCSLCKTRMIOS	const struct termios *\fP\fIargp\fP
端末の \fItermios\fP 構造体のロック状態を設定する。 root のみ (より正確には、 \fBCAP_SYS_ADMIN\fP
ケーパビリティを持つプロセス) がこれを実行できる。
.SS ウィンドウサイズの取得と設定
ウィンドウサイズはカーネル内に保持されるが、 カーネルによって使用されない (仮想コンソールの場合は例外であり、新しいフォントを読み込んだ場合など、
仮想端末のサイズが変更された場合、カーネルはウィンドウサイズを更新する)。

以下の定数と構造体は \fI<sys/ioctl.h>\fP で定義されている。
.TP 
\fBTIOCGWINSZ	struct winsize *\fP\fIargp\fP
ウィンドウサイズを取得する。
.TP 
\fBTIOCSWINSZ	const struct winsize *\fP\fIargp\fP
ウィンドウサイズを設定する。
.LP
これらの ioctl で使用される構造体は、以下のように定義される。

.in +4n
.nf
struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel;   /* 未使用 */
    unsigned short ws_ypixel;   /* 未使用 */
};
.fi
.in

ウィンドウサイズが変更された場合、 フォアグラウンドプロセスグループに \fBSIGWINCH\fP シグナルが送られる。
.SS "break の送信"
.TP 
\fBTCSBRK	int \fP\fIarg\fP
\fItcsendbreak(fd, arg)\fP と同じ。
.br
端末が非同期シリアルデータ転送を使用しており、 \fIarg\fP が 0 の場合、0.25 から 0.5 秒の間に break (0
のビット列のストリーム) が送信される。 端末が非同期シリアルデータ転送を使用している場合、 break が送信されるか、この関数は何もせずに返る。
\fIarg\fP が 0 以外の場合、何が起こるか分からない。

(SVr4, UnixWare, Solaris, Linux は、 \fItcsendbreak(fd,arg)\fP の \fIarg\fP が 0
以外の場合、 \fItcdrain(fd)\fP のように扱う。 SunOS は \fIarg\fP を倍数として扱い、ビットのストリームを \fIarg\fP
回送信する。 \fIarg\fP が 0 の場合も同じ。 DG/UX と AIX は、(0 以外の場合)  \fIarg\fP をミリ秒単位の時間間隔として扱う。
HP\-UX は \fIarg\fP を無視する。)
.TP 
\fBTCSBRKP	int \fP\fIarg\fP
いわゆる「POSIX 版」の \fBTCSBRK\fP である。 これは 0 以外の \fIarg\fP を 1/10 秒単位の時間間隔として扱う。 またドライバが
break をサポートしていない場合は、何もしない。
.TP 
\fBTIOCSBRK	void\fP
break をオンにする。 つまり 0 のビット列の送信を開始する。
.TP 
\fBTIOCCBRK	void\fP
break をオフにする。 つまり 0 のビット列の送信を停止する。
.SS ソフトウェアフロー制御
.TP 
\fBTCXONC	int \fP\fIarg\fP
\fItcflow(fd, arg)\fP と同じ。
.br
\fBtcflow\fP(3)  の引き数 \fBTCOOFF\fP, \fBTCOON\fP, \fBTCIOFF\fP, \fBTCION\fP を参照すること。
.SS "バッファのカウントと書き出し (flush)"
.TP 
\fBFIONREAD	int *\fP\fIargp\fP
入力バッファにあるバイト数を取得する。
.TP 
\fBTIOCINQ	int *\fP\fIargp\fP
\fBFIONREAD\fP と同じ。
.TP 
\fBTIOCOUTQ	int *\fP\fIargp\fP
出力バッファにあるバイト数を取得する。
.TP 
\fBTCFLSH	int \fP\fIarg\fP
\fItcflush(fd, arg)\fP と同じ。
.br
\fBtcflush\fP(3)  の引き数 \fBTCIFLUSH\fP, \fBTCOFLUSH\fP, \fBTCIOFLUSH\fP を参照すること。
.SS 入力の偽装
.TP 
\fBTIOCSTI	const char *\fP\fIargp\fP
指定されたバイトを入力キューに挿入する。
.SS コンソール出力のリダイレクト
.TP 
\fBTIOCCONS	void\fP
\fI/dev/console\fP または \fI/dev/tty0\fP に送られる出力を、指定された端末リダイレクトする。 指定された端末が疑似端末
(pseudoterminal) のマスタの場合、 出力はスレーブに送られる。 バージョン 2.6.10 より前の Linux
では、出力がまだリダイレクトされて いなければ、誰でもリダイレクトを行うことができる。 バージョン 2.6.10 以降では、root
(\fBCAP_SYS_ADMIN\fP ケーパビリティを持つプロセス) だけがリダイレクトを行うことができる。 出力がすでにリダイレクトされている場合は
\fBEBUSY\fP が返されるが、 \fI/dev/console\fP か \fI/dev/tty0\fP を指している \fIfd\fP に対してこの ioctl
を使用することで、リダイレクトを止めることができる。
.SS 端末の制御
.TP 
\fBTIOCSCTTY	int \fP\fIarg\fP
指定された端末を呼び出し元のプロセスの制御端末にする。 呼び出し元のプロセスはセッションリーダでなければならず、
かつ既に制御端末を持っていてはならない。 この端末が既に他のセッショングループの制御端末である場合、 ioctl は \fBEPERM\fP
で失敗する。ただし呼び出したユーザが root で (より正確には \fBCAP_SYS_ADMIN\fP ケーパビリティを持っていて)、かつ \fIarg\fP
が 1 である場合を除く。 この場合、端末は盗まれ (stolen)、 この端末を制御端末としていた全てのプロセスは端末を失う。
.TP 
\fBTIOCNOTTY	void\fP
指定された端末が呼び出し元のプロセスの制御端末である場合、 この制御端末を放棄する。 プロセスがセッションリーダの場合、
フォアグラウンドプロセスグループに \fBSIGHUP\fP と \fBSIGCONT\fP を送り、カレントセッションの全てのプロセスは制御端末を失う。
.SS "グループ ID とセッション ID の処理"
.TP 
\fBTIOCGPGRP	pid_t *\fP\fIargp\fP
成功した場合、 \fI*argp = tcgetpgrp(fd)\fP と同じ。
.br
この端末上のフォアグラウンドプロセスのプロセスグループ ID を取得する。
.TP 
\fBTIOCSPGRP	const pid_t *\fP\fIargp\fP
\fItcsetpgrp(fd, *argp)\fP と同じ。
.br
この端末のフォアグラウンドプロセスのグループ ID を設定する。
.TP 
\fBTIOCGSID	pid_t *\fP\fIargp\fP
指定された端末のセッション ID を取得する。 端末がマスタ疑似端末または制御端末でない場合は、 \fBENOTTY\fP で失敗する。 奇妙だ。
.SS 排他モード
.TP 
\fBTIOCEXCL	void\fP
端末を排他モードにする。 端末に対して、これ以降の \fBopen\fP(2)  操作を禁止する。 (root 以外の場合、つまり
\fBCAP_SYS_ADMIN\fP ケーパビリティを持たないプロセスの場合、これ以降の \fBopen\fP(2)  は \fBEBUSY\fP で失敗する。)
.TP 
\fBTIOCNXCL	void\fP
排他モードを無効にする。
.SS "ライン制御 (line discipline)"
.TP 
\fBTIOCGETD	int *\fP\fIargp\fP
端末のライン制御の情報を取得する。
.TP 
\fBTIOCSETD	const int *\fP\fIargp\fP
端末のライン制御の情報を設定する。
.SS "疑似端末の ioctl"
.TP 
\fBTIOCPKT	const int *\fP\fIargp\fP
パケットモードを有効 (*\fIargp\fP が 0 以外の場合) または無効にする。 疑似端末のマスタ側にのみ適用できる (それ以外の場合は
\fBENOTTY\fP を返す)。 パケットモードでは、その後に実行される \fBread\fP(2)  は、値が 0 以外の 1
つの制御バイトを含むパケットか、 値が 0 の 1 バイト (\(aq\e0\(aq) に疑似端末のスレーブ側で書き込まれた
データが続くパケットを返す。 最初のバイトが \fBTIOCPKT_DATA\fP (0) でない場合、以下のビットの 1 つ以上を OR したものである:

.nf
TIOCPKT_FLUSHREAD   端末の読み込みキューがフラッシュ (flush) される。
TIOCPKT_FLUSHWRITE  端末の書き出しキューがフラッシュされる。
TIOCPKT_STOP        端末への出力が停止される。
TIOCPKT_START       端末への出力が再開される。
TIOCPKT_DOSTOP      開始文字と終了文字が \fB^S\fP/\fB^Q\fP である。
TIOCPKT_NOSTOP      開始文字と終了文字が \fB^S\fP/\fB^Q\fP でない。
.fi

このモードが使われている場合、 制御状態情報の存在がマスタ側から読み込めるかは、 例外的な条件で \fBselect\fP(2)
を使うことにより知ることができる。

このモードは \fBrlogin\fP(1)  と \fBrlogind\fP(8)  で使われ、リモートエコーのリモートログインと ローカルでの
\fB^S\fP/\fB^Q\fP フロー制御のリモートログインを実装している。

BSD の ioctl である \fBTIOCSTOP\fP, \fBTIOCSTART\fP, \fBTIOCUCNTL\fP, \fBTIOCREMOTE\fP
は、Linux では実装されていない。
.SS モデム制御
.TP 
\fBTIOCMGET	int *\fP\fIargp\fP
モデムビット列の状態を取得する。
.TP 
\fBTIOCMSET	const int *\fP\fIargp\fP
モデムビット列の状態を設定する。
.TP 
\fBTIOCMBIC	const int *\fP\fIargp\fP
指定されたモデムビット列をクリアする。
.TP 
\fBTIOCMBIS	const int *\fP\fIargp\fP
指定されたモデムビット列を設定する。
.LP
これらの 4 つの ioctl で使われるビットは以下の通り:

.nf
TIOCM_LE        DSR (data set ready/line enable)
TIOCM_DTR       DTR (data terminal ready)
TIOCM_RTS       RTS (request to send)
TIOCM_ST        Secondary TXD (transmit)
TIOCM_SR        Secondary RXD (receive)
TIOCM_CTS       CTS (clear to send)
TIOCM_CAR       DCD (data carrier detect)
TIOCM_CD         TIOCM_CAR を参照。
TIOCM_RNG       RNG (ring)
TIOCM_RI         TIOCM_RNG を参照。
TIOCM_DSR       DSR (data set ready)
.fi
.SS 回線をローカルとしてマークする
.TP 
\fBTIOCGSOFTCAR	int *\fP\fIargp\fP
("ソフトウェアキャリアフラグの取得")  \fItermios\fP 構造体の c_cflag フィールドの \fBCLOCAL\fP フラグの状態を取得する。
.TP 
\fBTIOCSSOFTCAR	const int *\fP\fIargp\fP
("ソフトウェアキャリアフラグの設定")  *\fIargp\fP が 0 以外の場合、 \fItermios\fP 構造体の \fBCLOCAL\fP
フラグを設定する。 0 の場合はクリアする。
.LP
ラインの \fBCLOCAL\fP フラグがオフの場合、 ハードウェアキャリア検出 (hardware carrier detect, DCD)
シグナルが重要であり、 \fBO_NONBLOCK\fP フラグが指定されない限り、対応する端末の \fBopen\fP(2)  は DCD
が示されるまでブロックされる。 \fBCLOCAL\fP が設定されている場合、 ラインは常に DCD が示されているかのように動作する。
ソフトウェアキャリアフラグは、ローカルデバイスでは通常はオンになっており、 モデムのラインではオフになっている。
.SS "Linux 固有の ioctl"
\fBTIOCLINUX\fP ioctl については、 \fBconsole_ioctl\fP(4)  を参照すること。
.SS カーネルデバッギング
\fB#include <linux/tty.h>\fP
.TP 
\fBTIOCTTYGSTRUCT	struct tty_struct *\fP\fIargp\fP
.\"
.\" .SS "Serial info"
.\" .BR "#include <linux/serial.h>"
.\" .sp
.\" .TP
.\" .BI "TIOCGSERIAL	struct serial_struct *" argp
.\" Get serial info.
.\" .TP
.\" .BI "TIOCSSERIAL	const struct serial_struct *" argp
.\" Set serial info.
\fIfd\fP に対応する \fItty_struct\fP を取得する。
.SH 返り値
\fBioctl\fP(2)  システムコールは、成功した場合は 0 を返す。 エラーの場合は \-1 を返し、 \fIerrno\fP を適切に設定する。
.SH エラー
.TP 
\fBEINVAL\fP
不正なコマンド引き数である。
.TP 
\fBENOIOCTLCMD\fP
不明なコマンドである。
.TP 
\fBENOTTY\fP
\fIfd\fP が不適切である。
.TP 
\fBEPERM\fP
権限が不足している。
.SH 例
シリアルポートの DTR の状態をチェックする。

.nf
#include <termios.h>
#include <fcntl.h>
#include <sys/ioctl.h>

int
main(void)
{
    int fd, serial;

    fd = open("/dev/ttyS0", O_RDONLY);
    ioctl(fd, TIOCMGET, &serial);
    if (serial & TIOCM_DTR)
        puts("TIOCM_DTR が設定されていない。");
    else
        puts("TIOCM_DTR が設定されている。");
    close(fd);
}
.fi
.SH 関連項目
.\"
.\" FIONBIO			const int *
.\" FIONCLEX			void
.\" FIOCLEX			void
.\" FIOASYNC			const int *
.\" from serial.c:
.\" TIOCSERCONFIG		void
.\" TIOCSERGWILD		int *
.\" TIOCSERSWILD		const int *
.\" TIOCSERGSTRUCT		struct async_struct *
.\" TIOCSERGETLSR		int *
.\" TIOCSERGETMULTI		struct serial_multiport_struct *
.\" TIOCSERSETMULTI		const struct serial_multiport_struct *
.\" TIOCGSERIAL, TIOCSSERIAL (see above)
\fBioctl\fP(2), \fBtermios\fP(3), \fBconsole_ioctl\fP(4), \fBpty\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
