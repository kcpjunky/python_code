.\" t
.\" Don't change the first line, it tells man that tbl is needed.
.\" This man page is Copyright (c) 1998 by Andi Kleen. Subject to the GPL.
.\" Based on the original comments from Alexey Kuznetsov
.\" Modified 2005-12-27 by Hasso Tepper <hasso@estpak.ee>
.\" $Id: netlink.7,v 1.8 2000/06/22 13:23:00 ak Exp $
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH NETLINK 7 2012\-04\-14 Linux "Linux Programmer's Manual"
.SH 名前
netlink \- カーネルとユーザー空間の通信 (AF_NETLINK)
.SH 書式
.nf
\fB#include <asm/types.h>\fP
\fB#include <sys/socket.h>\fP
\fB#include <linux/netlink.h>\fP

\fBnetlink_socket = socket(AF_NETLINK, \fP\fIsocket_type\fP\fB, \fP\fInetlink_family\fP\fB);\fP
.fi
.SH 説明
netlink はカーネルモジュールとユーザー空間のプロセス間で 情報をやりとりするために用いられる。 netlink は、ユーザープロセスに対しては
標準的なソケットベースのインターフェースを、 カーネルモジュールにはカーネルの内部 API を提供する。 カーネル内部のインターフェースについてはこの
man ページでは記述しない。 また、netlink キャラクタデバイスを用いた obsolete な netlink
インターフェースもあるが、これもこの文書では解説しない。 これは単に過去互換性のために用意されているものにすぎない。

netlink はデータグラム指向のサービスである。 \fIsocket_type\fP には \fBSOCK_RAW\fP と \fBSOCK_DGRAM\fP
の両方とも指定可能である。 しかし netlink プロトコルはデータグラムと raw ソケットの区別をしない。

\fInetlink_family\fP は、通信するカーネルモジュールや netlink グループの選択に用いる。 現在割り当てられている netlink
ファミリーは以下の通り。
.TP 
\fBNETLINK_ROUTE\fP
ルーティングとリンクの更新を受信する。 (IPv4 と IPv6 両方の) ルーティングテーブル・ IP アドレス・リンクパラメータ・近傍設定
(neighbor setup)・ キューイングルール (queueing dicipline)・トラフィッククラス・
パケットのクラス分類の修正に用いることができるだろう (\fBrtnetlink\fP(7)  を見よ)。
.TP 
\fBNETLINK_W1\fP
単線 (1\-wire) のサブシステムからのメッセージ。
.TP 
\fBNETLINK_USERSOCK\fP
ユーザーモードソケットプロトコルのために予約されている。
.TP 
\fBNETLINK_FIREWALL\fP
IPv4 パケットを netfilter からユーザー空間へ転送する。 \fIip_queue\fP カーネルモジュールで使用される。
.TP 
\fBNETLINK_INET_DIAG\fP
.\" FIXME More details on NETLINK_INET_DIAG needed.
INET ソケットをモニタリングする。
.TP 
\fBNETLINK_NFLOG\fP
Netfilter/iptables ULOG.
.TP 
\fBNETLINK_XFRM\fP
.\" FIXME More details on NETLINK_XFRM needed.
IPsec.
.TP 
\fBNETLINK_SELINUX\fP
SELinux のイベント通知。
.TP 
\fBNETLINK_ISCSI\fP
.\" FIXME More details on NETLINK_ISCSI needed.
Open\-iSCSI.
.TP 
\fBNETLINK_AUDIT\fP
.\" FIXME More details on NETLINK_AUDIT needed.
監査 (audit) を行う。
.TP 
\fBNETLINK_FIB_LOOKUP\fP
.\" FIXME More details on NETLINK_FIB_LOOKUP needed.
ユーザー空間から FIB ルックアップにアクセスする。
.TP 
\fBNETLINK_CONNECTOR\fP
カーネルコネクタ。 より詳しい情報はカーネルソースの \fIDocumentation/connector/*\fP を参照すること。
.TP 
\fBNETLINK_NETFILTER\fP
.\" FIXME More details on NETLINK_NETFILTER needed.
netfilter サブシステム。
.TP 
\fBNETLINK_IP6_FW\fP
IPv6 パケットを netfilter からユーザー空間へ転送する。 \fIip6_queue\fP カーネルモジュールで使用される。
.TP 
\fBNETLINK_DNRTMSG\fP
DECnet ルーティングメッセージ。
.TP 
\fBNETLINK_KOBJECT_UEVENT\fP
.\" FIXME More details on NETLINK_KOBJECT_UEVENT needed.
ユーザー空間へのカーネルメッセージ
.TP 
\fBNETLINK_GENERIC\fP
netlink を簡単に使用するための一般的な netlink ファミリー。
.PP
netlink メッセージはバイトストリームからなり、 一つ以上の \fInlmsghdr\fP ヘッダと、それに対応するペイロード (payload)
が含まれる。 バイトストリームには、標準の \fBNLMSG_*\fP マクロによってのみアクセスすべきである。 より詳しい情報は \fBnetlink\fP(3)
を見よ。

マルチパートメッセージ (一つ以上の \fInlmsghdr\fP ヘッダと、それに対応するペイロードが 一つバイトストリームに含まれる) においては、
先頭のヘッダ・後続のヘッダには \fBNLM_F_MULTI\fP フラグがセットされる。ただし最後のヘッダだけは例外で、 \fBNLMSG_DONE\fP
タイプとなる。

それぞれの \fBnlmsghdr\fP の後にはペイロードが続く。

.in +4n
.nf
struct nlmsghdr {
    __u32 nlmsg_len;    /* ヘッダを含むメッセージの長さ */
    __u16 nlmsg_type;   /* メッセージの内容のタイプ */
    __u16 nlmsg_flags;  /* 追加フラグ */
    __u32 nlmsg_seq;    /* シーケンス番号 */
    __u32 nlmsg_pid;    /* 送信プロセスの PID */
};
.fi
.in

\fInlmsg_type\fP は標準のメッセージタイプのどれか一つである: \fBNLMSG_NOOP\fP メッセージは無視される。
\fBNLMSG_ERROR\fP メッセージはエラーを示し、ペイロードには \fInlmsgerr\fP 構造体が入る。 \fBNLMSG_DONE\fP
メッセージはマルチパートメッセージの終了を伝える。

.in +4n
.nf
struct nlmsgerr {
    int error;        /* 負または 0 の errno は応答を表す */
    struct nlmsghdr msg;  /* エラーを起こしたメッセージのヘッダ */
};
.fi
.in

ある netlink ファミリーで指定できるメッセージタイプは、 通常もっと多い。これらに関しては適切な man ページを見てほしい。 たとえば
\fBNETLINK_ROUTE\fP に関しては \fBrtnetlink\fP(7)  に書いてある。

\fInlmsg_flags\fP の標準フラグビット
.br
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.TS
tab(:);
lB l.
NLM_F_REQUEST:要求メッセージ全てでセットされなければならない。
NLM_F_MULTI:T{
このメッセージはマルチパートメッセージの一部である。
マルチパートメッセージは \fBNLMSG_DONE\fP で終端する。
T}
NLM_F_ACK:成功した場合の応答を要求する。
NLM_F_ECHO:この要求をエコーする。
.TE

GET 要求における追加フラグビット
.br
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.TS
tab(:);
lB l.
NLM_F_ROOT:単一のエントリではなくテーブル全体を返す。
NLM_F_MATCH:T{
メッセージの内容で渡された基準 (criteria) にマッチする全てのエントリを返す。
まだ実装されていない。
T}
.\" FIXME NLM_F_ATOMIC is not used any more?
NLM_F_ATOMIC:テーブルのアトミックなスナップショットを返す。
NLM_F_DUMP:便利なマクロ。(NLM_F_ROOT|NLM_F_MATCH) と同じ。
.TE

\fBNLM_F_ATOMIC\fP を使う場合は、 \fBCAP_NET_ADMIN\fP 権限を持つか実効ユーザー ID が 0
でなければならない点に注意すること。

NEW 要求における追加フラグビット
.br
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.TS
tab(:);
lB l.
NLM_F_REPLACE:現存のオブジェクトを置換する。
NLM_F_EXCL:すでにオブジェクトがあったら置換しない。
NLM_F_CREATE:まだオブジェクトがなければ作成する。
NLM_F_APPEND:オブジェクトリストの最後に追加する。
.TE

\fInlmsg_seq\fP と \fInlmsg_pid\fP はメッセージの追跡に使用される。 \fInlmsg_pid\fP はメッセージの送信元を表す。
メッセージが netlink ソケットで送信されている場合、 \fInlmsg_pid\fP とプロセスの PID は 1:1
の関係ではない点に注意すること。 より詳しい情報は、 「\fBアドレスのフォーマット\fP」 のセクションを参照すること。

.\" FIXME Explain more about nlmsg_seq and nlmsg_pid.
\fInlmsg_seq\fP と \fInlmsg_pid\fP は netlink のコアには見えない (opaque)。

netlink は信頼性の高いプロトコルではない。 netlink はメッセージを行き先に届けるために最善を尽くすが、
メモリが足りなかったりエラーが起こったりすると メッセージを取りこぼすこともある。 信頼性の高い転送を行いたいときは、
送信者は受信者に応答を要求することもできる。 これには \fBNLM_F_ACK\fP フラグをセットする。 応答は \fBNLMSG_ERROR\fP
パケットのエラーフィールドを 0 にしたものになる。 アプリケーションは自分自身のメッセージを受けたときには、 応答を生成しなければならない。
カーネルは失敗したパケットに対して、 \fBNLMSG_ERROR\fP メッセージを送ろうとする。 ユーザープロセスはこの慣習にも従う必要がある。

しかし、どのような場合でもカーネルからユーザーへの 信頼性の高い転送は不可能である。 ソケットバッファが満杯の場合、カーネルは netlink
メッセージを送信できない。 メッセージは取りこぼされて、カーネルとユーザー空間プロセスは、 カーネルの状態についての同じビューを持つことができなくなる。
これが起こったこと (\fBrecvmsg\fP(2)  によって \fBENOBUFS\fP エラーが返される) を検知して再び同期させるのは、
アプリケーションの責任である。
.SS アドレスのフォーマット
\fIsockaddr_nl\fP 構造体はユーザー空間やカーネル空間で netlink クライアントを記述する。 \fIsockaddr_nl\fP
はユニキャスト (単一の接続先にだけ送られる) にもできるし、 netlink マルチキャストグループ (\fInl_groups\fP が 0 でない場合)
にも送ることができる。

.in +4n
.nf
struct sockaddr_nl {
    sa_family_t     nl_family;  /* AF_NETLINK */
    unsigned short  nl_pad;     /* 0 である */
    pid_t           nl_pid;     /* プロセス ID */
    __u32           nl_groups;  /* マルチキャストグループマスク */
};
.fi
.in

\fInl_pid\fP は netlink ソケットのユニキャストアドレスである。 行き先がカーネルの場合は、常に 0 である。
ユーザー空間プロセスの場合、通常は \fInl_pid\fP は行き先のソケットを所有しているプロセスの PID である。 ただし、 \fInl_pid\fP
はプロセスではなく netlink ソケットを同定する。 プロセスが複数の netlink ソケットを所有する場合、 \fInl_pid\fP
は最大でも一つのソケットのプロセス ID としか等しくならない。 \fInl_pid\fP を netlink ソケットに割り当てる方法は 2 つある。
アプリケーションが \fBbind\fP(2)  を呼ぶ前に \fInl_pid\fP を設定する場合、 \fInl_pid\fP
が一意であることを確認するのはアプリケーションの責任となる。 アプリケーションが \fInl_pid\fP を 0
に設定した場合、カーネルがこの値を割り当てる。 カーネルはプロセスが最初にオープンした netlink ソケットに対してプロセス ID を割り当て、
それ以降にプロセスが作成した全ての netlink ソケットにも一意な \fInl_pid\fP を割り当てる。

\fInl_groups\fP はビットマスクで、すべてのビットが netlink グループ番号を表す。
それぞれの netlink ファミリーは 32 のマルチキャストグループのセットを持つ。
それぞれの netlink ファミリーは 32 のマルチキャストグループの セットを持つ。
\fBbind\fP(2) がソケットに対して呼ばれると、 \fIsockaddr_nl\fP の \fInl_groups\fP
フィールドには listen したいグループのビットマスクがセットされる。
デフォルトの値は 0 で、マルチキャストを一切受信しない。
\fBsendmsg\fP(2) や \fBconnect\fP(2) によって、あるソケットからメッセージを
マルチキャストしたいときは、 \fInl_groups\fP に送信したいグループのビットマスク
をセットすればよい。
実効ユーザー ID が 0 か、 \fBCAP_NET_ADMIN\fP 権限を持つユーザーのみが netlink
マルチキャストグループに 送信したり、これを listen したりすることができる。
マルチキャストグループ向けメッセージを受信した場合、これ対する応答は
送り主の PID とマルチキャストグループとに送り返すべきである。
さらに、Linux のカーネルサブシステムによっては、
他のユーザもメッセージの送受信ができる場合がある。
Linux 3.0 の時点では、
\fBNETLINK_KOBJECT_UEVENT\fP, \fBNETLINK_GENERIC\fP, \fBNETLINK_ROUTE\fP,
\fBNETLINK_SELINUX\fP グループでは他のユーザがメッセージを受信することができる。
他のユーザがメッセージを送信できるグループは存在しない。
.SH バージョン
netlink へのソケットインターフェースは Linux 2.2 の新機能である。

Linux 2.0 は、もっと原始的なデバイスベースの netlink インターフェースを サポートしていた (これも互換性のために今でも使用できる)。
古いインターフェースに関してはここでは記述しない。

NETLINK_SELINUX は Linux 2.6.4 で登場した。

NETLINK_AUDIT は Linux 2.6.6 で登場した。

NETLINK_KOBJECT_UEVENT は Linux 2.6.10 で登場した。

NETLINK_W1, NETLINK_FIB_LOOKUP は Linux 2.6.13 で登場した。

NETLINK_INET_DIAG, NETLINK_CONNECTOR, NETLINK_NETFILTER は Linux 2.6.14
で登場した。

NETLINK_GENERIC, NETLINK_ISCSI は Linux 2.6.15 で登場した。
.SH 注意
低レベルのカーネルインターフェースより、 \fIlibnetlink\fP または \fIlibnl\fP を通して netlink
を利用するほうが良いことが多い。
.SH バグ
この man ページは完成していない。
.SH 例
以下の例では、 \fBRTMGRP_LINK\fP (ネットワークインターフェースの create/delete/up/down イベント) と
\fBRTMGRP_IPV4_IFADDR\fP (IPv4 アドレスの add/delete イベント) マルチキャストグループを listen する
\fBNETLINK_ROUTE\fP netlink を作成している。

.in +4n
.nf
struct sockaddr_nl sa;

memset(&sa, 0, sizeof(sa));
sa.nl_family = AF_NETLINK;
sa.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR;

fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
bind(fd, (struct sockaddr *) &sa, sizeof(sa));
.fi
.in

次の例では、netlink メッセージをカーネル (pid 0) に送る方法を示している。 応答を追跡する際の信頼性を高めるために、アプリケーションが
メッセージのシーケンス番号を正しく処理しなければならない点に注意すること。

.in +4n
.nf
struct nlmsghdr *nh;    /* 送信する nlmsghdr とペイロード */
struct sockaddr_nl sa;
struct iovec iov = { (void *) nh, nh\->nlmsg_len };
struct msghdr msg;

msg = { (void *)&sa, sizeof(sa), &iov, 1, NULL, 0, 0 };
memset(&sa, 0, sizeof(sa));
sa.nl_family = AF_NETLINK;
nh\->nlmsg_pid = 0;
nh\->nlmsg_seq = ++sequence_number;
/* NLM_F_ACK を設定することで、カーネルに応答を要求する */
nh\->nlmsg_flags |= NLM_F_ACK;

sendmsg(fd, &msg, 0);
.fi
.in

最後は、netlink メッセージの読み込みの例である。

.in +4n
.nf
int len;
char buf[4096];
struct iovec iov = { buf, sizeof(buf) };
struct sockaddr_nl sa;
struct msghdr msg;
struct nlmsghdr *nh;

msg = { (void *)&sa, sizeof(sa), &iov, 1, NULL, 0, 0 };
len = recvmsg(fd, &msg, 0);

for (nh = (struct nlmsghdr *) buf; NLMSG_OK (nh, len);
     nh = NLMSG_NEXT (nh, len)) {
    /* マルチパートメッセージの終わり */
    if (nh\->nlmsg_type == NLMSG_DONE)
        return;

    if (nh\->nlmsg_type == NLMSG_ERROR)
        /* 何らかのエラー処理を行う */
    ...

    /* ペイロードの解析を続ける */
    ...
}
.fi
.in
.SH 関連項目
\fBcmsg\fP(3), \fBnetlink\fP(3), \fBcapabilities\fP(7), \fBrtnetlink\fP(7)
.PP
libnetlink に関する情報は ftp://ftp.inr.ac.ru/ip\-routing/iproute2*

libnl に関する情報は http://people.suug.ch/~tgr/libnl/

RFC 3549 "Linux Netlink as an IP Services Protocol"
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
