.\" Page by b.hubert - may be freely modified and distributed
.\"
.\" Niki A. Rahimi (LTC Security Development, narahimi@us.ibm.com)
.\" added ERRORS section.
.\"
.\" Modified 2004-06-17 mtk
.\" Modified 2004-10-07 aeb, added FUTEX_REQUEUE, FUTEX_CMP_REQUEUE
.\"
.\" FIXME See also https://bugzilla.kernel.org/show_bug.cgi?id=14303
.\" 2.6.14 adds FUTEX_WAKE_OP
.\" 2.6.18 adds (Ingo Molnar) priority inheritance support:
.\" FUTEX_LOCK_PI, FUTEX_UNLOCK_PI, and FUTEX_TRYLOCK_PI.  These need
.\" to be documented in the manual page.  Probably there is sufficient
.\" material in the kernel source file Documentation/pi-futex.txt.
.\" 2.6.25 adds FUTEX_WAKE_BITSET, FUTEX_WAIT_BITSET
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH FUTEX 2 2010\-08\-29 Linux "Linux Programmer's Manual"
.SH 名前
futex \- 高速ユーザ空間ロック機構のシステムコール
.SH 書式
.nf
.sp
\fB#include <linux/futex.h>\fP
\fB#include <sys/time.h>\fP
.sp
\fBint futex(int *\fP\fIuaddr\fP\fB, int \fP\fIop\fP\fB, int \fP\fIval\fP\fB, const struct timespec *\fP\fItimeout\fP\fB,\fP
.br
.\" int *? void *? u32 *?
\fB          int *\fP\fIuaddr2\fP\fB, int \fP\fIval3\fP\fB);\fP
.fi
.SH 説明
.PP
\fBfutex\fP()  システムコールは、 指定したアドレスの値が変更されるのをプログラムが待つ手段や 特定のアドレスに対して待機中のプロセスを
wake (起床) させる手段を提供する (プロセスが異なれば同じメモリに対するアドレスも同じではないかもしれないが、
カーネルは異なる位置にマップされた同じメモリを \fBfutex\fP()  で使えるよう内部でマップする)。 通常は、このシステムコールは
\fBfutex\fP(7)  に書かれているように、 共有メモリ中のロックが競合する場合の処理を実装するのに用いられる。
.PP
\fBfutex\fP(7)  の操作がユーザ空間で競合なく完了しなかった場合、 カーネルに仲裁させるためにシステムコールを呼ぶ必要がある。
仲裁というのは、呼び出しプロセスを sleep (起床待ち) させたり、反対に 待ちプロセスを wake させたりすることを意味する。
.PP
この関数を呼び出すプロセスは \fBfutex\fP(7)  に記述されているセマンティクスに忠実であることが要求される。
このセマンティクスには移植不可能なアセンブリ命令を書くことが含まれる。 このことは言い換えると futex
のユーザのほとんどは実際はライブラリの作者であり、 一般アプリケーションの開発者ではないということである。
.PP
\fIuaddr\fP 引き数は、カウンタを格納する、 アラインメントの揃った int 型変数を指している必要がある。 実行する操作は \fIop\fP
引き数を介して、値 \fIval\fP とともに渡される。
.PP
現在のところ 5 つの操作が定義されている:
.TP 
\fBFUTEX_WAIT\fP
この操作は futex アドレス \fIuaddr\fP に指定された値 \fIval\fP がまだ格納されているかどうかを不可分操作で検証し、 sleep 状態で
この futex アドレスに対して \fBFUTEX_WAKE\fP が実行されるのを待つ。 \fItimeout\fP 引き数が NULL でない場合、その内容は
待ち時間の最大値を表す。NULL の場合は無限大を表す。 引き数 \fIuaddr2\fP と \fIval3\fP は無視される。

\fBfutex\fP(7)  に照らし合わせると、この呼び出しは カウントのデクリメントで負の値 (競合を表す) になった場合に実行され、
別のプロセスがその futex を解放し \fBFUTEX_WAKE\fP の操作を実行するまで sleep する。
.TP 
\fBFUTEX_WAKE\fP
この操作では指定した futex アドレスに対して待ち状態の (すなわち \fBFUTEX_WAIT\fP 中の) 最大 \fIval\fP 個のプロセスを
wake させる。 引き数 \fItimeout\fP, \fIuaddr2\fP, \fIval3\fP は無視される。

\fBfutex\fP(4) に照らし合わせると、 この操作は カウントのインクリメントで待ちプロセスがあると判明し、 futex 値が 1 に設定された
(利用可能であることを表す) 場合に実行される。
.TP 
\fBFUTEX_FD\fP (Linux 2.6.25 以前)
.\" , suitable for .BR poll (2).
非同期の wake に対応するため、この操作はファイルディスクリプタを futex に 関連づける。 別のプロセスが \fBFUTEX_WAKE\fP
を実行すると、プロセスは \fIval\fP で渡されたシグナル番号のシグナルを受信する。 呼び出しプロセスは使用後、返されたファイルディスクリプタを
クローズしなければならない。 引き数 \fItimeout\fP, \fIuaddr2\fP, \fIval3\fP は無視される。

競合状態を防止するため、呼び出しプロセスは \fBFUTEX_FD\fP が返ったあと futex が up されたかどうかを確認しなければならない。

\fBFUTEX_FD\fP はもともと競合が起きやすかったため、 Linux 2.6.26 以降で削除されている。
.TP 
\fBFUTEX_REQUEUE\fP (Linux 2.5.70 以降)
この操作は、 \fBFUTEX_WAKE\fP が使われていて、かつ wake されている全てのプロセスが 他の futex を取得する必要がある場合に、
「獣の群れの暴走 (thundering herd)」効果を避けるために導入された。 この呼び出しは \fIval\fP 個のプロセスを wake
し、アドレス \fIuaddr2\fP で futex を待っている他の全てのプロセスを再度キューにいれる。 引き数 \fItimeout\fP と \fIval3\fP
は無視される。
.TP 
\fBFUTEX_CMP_REQUEUE\fP (Linux 2.6.7 以降)
故意に \fBFUTEX_REQUEUE\fP を使う場合に競合が起こるため、 \fBFUTEX_CMP_REQUEUE\fP が導入された。これは
\fBFUTEX_REQUEUE\fP と似ているが、場所 \fIuaddr\fP に値 \fIval3\fP がまだ保持されているかを最初にチェックする。
保持されていない場合、操作はエラー \fBEAGAIN\fP で失敗する。引き数 \fItimeout\fP は無視される。
.SH 返り値
.PP
どの操作が実行されたかによって、 成功時の返り値の意味が変わる。
.TP 
\fBFUTEX_WAIT\fP
プロセスが \fBFUTEX_WAKE\fP の呼び出しで wake すると 0 を返す。 タイムアウトの場合、操作はエラー \fBETIMEOUT\fP
で失敗する。 futex が指定された値と等しくない場合、 エラー \fBEWOULDBLOCK\fP で失敗する。 シグナルを受信するか
(\fBsignal\fP(7)  参照) 他の偽の wake があった場合には、エラー \fBEINTR\fP で失敗する。
.TP 
\fBFUTEX_WAKE\fP
wake したプロセスの数を返す。
.TP 
\fBFUTEX_FD\fP
futex に関連づけられた新たなファイルディスクリプタを返す。
.TP 
\fBFUTEX_REQUEUE\fP
wake したプロセスの数を返す。
.TP 
\fBFUTEX_CMP_REQUEUE\fP
wake したプロセスの数を返す。
.PP
エラーの場合、全ての操作で \-1 が返り、 \fIerrno\fP がエラーの内容を示す値に設定される。
.SH エラー
.TP 
\fBEACCES\fP
futex メモリに読み込みアクセス権がなかった。
.TP 
\fBEAGAIN\fP
\fBFUTEX_CMP_REQUEUE\fP で予期しない futex 値が見つかった (これは競合を示しているかもしれない。 この場合は安全な
\fBFUTEX_WAKE\fP を使うこと)。
.TP 
\fBEFAULT\fP
ユーザ空間から \fItimeout\fP の情報を取得する際にエラーが発生した。
.TP 
\fBEINVAL\fP
操作が定義されていない。またはページ・アラインメントでエラーが発生した。
.TP 
\fBENFILE\fP
オープンされているファイルの総数がシステムの制限に達した。
.TP 
\fBENOSYS\fP
\fIop\fP に無効な操作が指定された。
.SH バージョン
.PP
最初の futex 対応は Linux 2.5.7 で組み込まれたが、 上記のセマンティクスとは異なる。 4
つの引き数のここに書かれているセマンティクスを持つ システムコールは、Linux 2.5.40 で導入された。 Linux 2.5.70 では 1
つの引き数が追加された。 Linux 2.6.7 では 6 番目の引き数が追加された。 これは汚く、s390 アーキテクチャ上の特別のものである。
.SH 準拠
このシステムコールは Linux 固有である。
.SH 注意
.PP
.\" .SH "AUTHORS"
.\" .PP
.\" Futexes were designed and worked on by
.\" Hubertus Franke (IBM Thomas J. Watson Research Center),
.\" Matthew Kirkwood, Ingo Molnar (Red Hat)
.\" and Rusty Russell (IBM Linux Technology Center).
.\" This page written by bert hubert.
繰り返すが、裸の futex はエンドユーザが容易に使うことのできる概念として 意図されたものではない (glibc
にはこのシステムコールに対するラッパー関数はない)。 実装者は、アセンブリ言語に慣れており、以下に挙げる futex ユーザ空間ライブラリの
ソースを読み終えていることが要求される。
.SH 関連項目
\fBfutex\fP(7)
.PP
\fIFuss, Futexes and Furwocks: Fast Userlevel Locking in Linux\fP (proceedings
of the Ottawa Linux Symposium 2002), online at
.br
http://kernel.org/doc/ols/2002/ols2002\-pages\-479\-495.pdf
.PP
futex の使用例ライブラリ, futex\-*.tar.bz2
.br
ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/.
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
