.\" This man page is Copyright (C) 2000 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: ipv6.7,v 1.3 2000/12/20 18:10:31 ak Exp $
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH IPV6 7 2012\-05\-10 Linux "Linux Programmer's Manual"
.SH 名前
ipv6 \- Linux IPv6 プロトコルの実装
.SH 書式
\fB#include <sys/socket.h>\fP
.br
\fB#include <netinet/in.h>\fP
.sp
\fItcp6_socket\fP\fB = socket(AF_INET6, SOCK_STREAM, 0);\fP
.br
\fIraw6_socket\fP\fB = socket(AF_INET6, SOCK_RAW, \fP\fIprotocol\fP\fB);\fP
.br
\fIudp6_socket\fP\fB = socket(AF_INET6, SOCK_DGRAM, \fP\fIprotocol\fP\fB);\fP
.SH 説明
Linux 2.2 では、Internet Protocol, version 6 を オプションとして実装している。 この man
ページでは、Linux カーネルと glibc 2.1 での実装に基づいて、 IPv6 の基本的な API を解説する。 インターフェースは BSD
ソケットインターフェースをもとにしている。 \fBsocket\fP(7)  を参照。
.PP
IPv6 API は、 IPv4 API (\fBip\fP(7)  参照) とほぼ互換になることを目指している。 この man
ページでは相違点のみを解説する。
.PP
\fBAF_INET6\fP ソケットを何らかのプロセスにバインドするには、 ローカルアドレスを \fIin6_addr\fP 型の変数
\fIin6addr_any\fP からコピーしてくる必要がある。 static な初期値 \fBIN6ADDR_ANY_INIT\fP
も用いることができ、これは定数式に展開される。 これらの両者はネットワークバイトオーダーである。
.PP
IPv6 のループバックアドレス (::1) は global 変数 \fIin6addr_loopback\fP から取得できる。初期化には
\fBIN6ADDR_LOOPBACK_INIT\fP を用いるべきである。
.PP
v4\-mapped\-on\-v6 アドレス型を用いることで、 IPv4 接続も v6 API で扱うことができる。 こうすれば、プログラムは v6 の
API をサポートするだけで、 両方のプロトコルをサポートできる。 v4\-mapped\-on\-v6 アドレス型は C ライブラリ内部のアドレスを
扱う関数によって透過的に処理される。
.PP
IPv4 と IPv6 はローカルポート空間を共有する。 IPv4 の接続 (またはパケット) を IPv6 ソケットが取得すると、 発信元アドレスが
v6 にマップされ、その接続 (パケット) も v6 にマップされる。
.SS アドレスのフォーマット
.in +4n
.nf
struct sockaddr_in6 {
    sa_family_t     sin6_family;   /* AF_INET6 */
    in_port_t       sin6_port;     /* port number */
    uint32_t        sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr;     /* IPv6 address */
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */
};

struct in6_addr {
    unsigned char   s6_addr[16];   /* IPv6 address */
};
.fi
.in
.sp
\fIsin6_family\fP は常に \fBAF_INET6\fP に設定される。
\fIsin6_port\fP はプロトコルポートである (\fBip\fP(7) の \fIsin_port\fP を参照)。
\fIsin6_flowinfo\fP は IPv6 のフロー指定子 (flow identifier) である。
\fIsin6_addr\fP は 128 ビットの IPv6 アドレスである。 \fIsin6_scope_id\fP は
アドレスのスコープに依存した ID である (これは Linux 2.4 で導入された)。
Linux の場合は、これはリンクローカルアドレスでのみサポートされている。
この場合 \fIsin6_scope_id\fP にはインターフェースのインデックスが含まれる
ことになる (\fBnetdevice\fP(7) を参照)。
.PP
IPv6 は何種類かのアドレスタイプをサポートしている。 単一のホストをアドレスするための unicast、 ホストのグループをアドレスするための
multicast、 ホストのグループ中で最も近くにいるものをアドレスするための anycast (これは Linux では実装されていない)、
IPv4 ホストをアドレスするための IPv4\-on\-IPv6。 他にも予約済みのアドレスタイプがある。
.PP
IPv6 でのアドレス表記は 4 桁の 16 進数 8 個からなり、 \(aq:\(aq は区切り文字はで、"::" は 0 ビットの文字列を表す。
特殊なアドレスとして、ループバックを表す ::1、 IPv4\-mapped\-on\-IPv6 を表す ::FFFF::<IPv4
アドレス> がある。
.PP
IPv6 のポート空間は IPv4 と共有されている。
.SS ソケットオプション
IPv6 はプロトコル固有のソケットオプションをいくつかサポートしている。 これらは \fBsetsockopt\fP(2)  で設定でき、
\fBgetsockopt\fP(2)  で取得できる。 IPv6 のソケットオプションレベルは \fBIPPROTO_IPV6\fP である。
ブール整数のフラグは、0 が偽であり、それ以外は真である。
.TP 
\fBIPV6_ADDRFORM\fP
\fBAF_INET6\fP ソケットを別のアドレスファミリーのソケットに変える。 現在は \fBAF_INET\fP
のみが変更先のアドレスファミリーとしてサポートされている。 これが許可されるのは、IPv6 が接続され、 v4\-mapped\-on\-v6
アドレスにバインドされた場合に限られる。 引き数は \fBAF_INET\fP が入っている整数へのポインタである。 v4\-mapped ソケットを、IPv6
API を扱えないプログラムに対して ファイルディスクリプターとして渡す場合に便利。
.TP 
\fBIPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP\fP
.\" FIXME IPV6_CHECKSUM is not documented, and probably should be
.\" FIXME IPV6_JOIN_ANYCAST is not documented, and probably should be
.\" FIXME IPV6_LEAVE_ANYCAST is not documented, and probably should be
.\" FIXME IPV6_RECVPKTINFO is not documented, and probably should be
.\" FIXME IPV6_2292PKTINFO is not documented, and probably should be
.\" FIXME there are probably many other IPV6_* socket options that
.\" should be documented
multicast グループのメンバーを制御する。 引き数は \fIstruct ipv6_mreq\fP 構造体へのポインタ。
.TP 
\fBIPV6_MTU\fP
そのソケットに対して用いる MTU の値を設定する。 MTU の大きさは、 そのデバイスの MTU または (Path MTU Discovery
が可能なら) その経路の MTU の大きさ以下でなければならない。 引き数は整数へのポインタ。
.TP 
\fBIPV6_MTU_DISCOVER\fP
そのソケットでの Path MTU Discovery を制御する。 詳細は \fBip\fP(7)  の \fBIP_MTU_DISCOVER\fP を参照。
.TP 
\fBIPV6_MULTICAST_HOPS\fP
そのソケットでの multicast の hop 数の上限値を設定する。 引き数は整数へのポインタである。 \-1
を指定すると経路のデフォルトを用いることを意味する。 それ以外の場合は 0 から 255 の範囲を指定する。
.TP 
\fBIPV6_MULTICAST_IF\fP
そのソケットでの、送信 multicast パケットに用いるデバイスを設定する。 これは \fBSOCK_DGRAM\fP および \fBSOCK_RAW\fP
各ソケットでのみ許される。 引き数はインターフェースのインデックスの整数値 (\fBnetdevice\fP(7)  を参照) へのポインタである。
.TP 
\fBIPV6_MULTICAST_LOOP\fP
ソケットが、自分自身の送信した multicast パケットを監視するかどうかを制御する。 引き数はブール値へのポインタ。
.TP 
\fBIPV6_PKTINFO\fP
データグラムの到着時における \fBIPV6_PKTINFO\fP 制御メッセージを配送するかどうかを設定する。 \fBSOCK_DGRAM\fP ソケットまたは
\fBSOCK_RAW\fP ソケットに対してのみ許可される。 引き数はブール値の入った整数。
.TP 
.nh
\fBIPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO,
IPV6_HOPLIMIT\fP
.hy
受信パケットのデータグラムに拡張ヘッダが含まれている場合の、 制御メッセージの配送を設定する。 \fBIPV6_RTHDR\fP: routing
ヘッダを配送するかどうか。 \fBIPV6_AUTHHDR\fP: authentication ヘッダを配送するかどうか。 \fBIPV6_DSTOPTS\fP:
destination オプションを配送するかどうか。 \fBIPV6_HOPOPTS\fP: hop オプションを配送するかどうか。
\fBIPV6_FLOWINFO\fP: flow ID を含む整数を配送するかどうか。 \fBIPV6_HOPLIMIT\fP: パケットの hop
カウントを含む整数を配送するかどうか。 制御メッセージはソケットオプションのものと同じタイプを持つ。 これらのすべてのヘッダオプションは、
適切な制御メッセージを \fBsendmsg\fP(2)  の制御バッファーに書きこめば、 送信パケットにでも設定できる。 \fBSOCK_DGRAM\fP
ソケットまたは \fBSOCK_RAW\fP ソケットでのみ許される。引き数はブール値へのポインタ。
.TP 
\fBIPV6_RECVERR\fP
非同期エラー (asynchronous error) オプションの受信を制御する。 詳細は \fBip\fP(7)  の \fBIP_RECVERR\fP
を参照。 引き数はブール値へのポインタ。
.TP 
\fBIPV6_ROUTER_ALERT\fP
このソケットで、router alert hop\-by\-hop オプションの付いた転送パケットを 通すかどうかを制御する。 \fBSOCK_RAW\fP
ソケットでのみ許可される。 tap されたパケットはカーネルによっては転送されない。そうしたパケットを 再度送信するのはユーザーの責任である。
引き数は整数 (integer) へのポインタ。 正の整数は傍受を行う router alert オプション値を示す。 オプション値がこの整数である
router alert オプションの付いたパケットは ソケットに配送される。負の整数を指定すると、このソケットへの router alert
オプションの付いたパケットの配送が行われない。
.TP 
\fBIPV6_UNICAST_HOPS\fP
そのソケットでの unicast の hop 数の上限値を設定する。 引き数は整数へのポインタである。 \-1
を指定すると経路のデフォルトを用いることを意味する。 それ以外の場合は 0 から 255 の範囲を指定する。
.TP 
\fBIPV6_V6ONLY\fP (Linux 2.4.21 以降および 2.6 以降)
.\" See RFC 3493
このフラグを真 (0 以外) に設定すると、そのソケットは IPv6 パケットだけを 送受信するように制限される。 この場合、IPv4
アプリケーションと IPv6 アプリケーションが同時に 一つのポートをバインドできる。

このフラグを偽 (0) に設定すると、そのソケットはパケットの送受信に IPv6 アドレスと IPv4\-mapped IPv6
アドレスの両方を使用できる。

引き数はブール値の入った整数へのポインタである。

.\" FLOWLABEL_MGR, FLOWINFO_SEND
このフラグのデフォルト値はファイル \fI/proc/sys/net/ipv6/bindv6only\fP の内容により定義される。
このファイルのデフォルト値は 0 (偽) である。
.SH エラー
.\" FIXME document all errors.
.TP 
\fBENODEV\fP
ユーザがリンクローカルの IPv6 アドレスを \fBbind\fP(2) しようとしたが、
指定された \fIsockaddr_in6\fP 構造体の \fIsin6_scope_id\fP が
有効なインターフェースのインデックスでなかった。
.SH バージョン
IPv6 API を libc5 ベースで Linux 向けに実装した、以前の \fIlibinet6\fP についてはここでは記述していない。
おそらく細かいところには相違点があるだろう。
.PP
Linux 2.4 では 64 ビットのホストに対して \fIsockaddr_in6\fP のバイナリ互換性が保たれていない。 \fIin6_addr\fP
のアラインメントが変更され、また \fIsin6_scope_id\fP フィールドが新たに追加されたからである。
カーネルインターフェースの互換性は保たれているが、 \fIsockaddr_in6\fP や \fIin6_addr\fP
を他の構造体に含んでいるようなプログラムでは 保たれないかもしれない。 これは i386 のような 32 ビットのホストでは問題にならない。
.PP
\fIsin6_flowinfo\fP フィールドは Linux 2.4 で登場した。 これが渡されたアドレス長に含まれていると、
カーネルに透過的に渡され、読まれる。 より長いアドレスバッファを渡し、 そして送信アドレスの長さをチェックするようなプログラムは
うまく動かないかもしれない。
.SH 注意
\fIsockaddr_in6\fP 構造体はジェネリックな \fIsockaddr\fP よりも大きい。 すべてのアドレスタイプが \fIstruct
sockaddr\fP の中に安全に納められると仮定しているプログラムは、代わりに \fIstruct sockaddr_storage\fP
を用いるように変更する必要がある。
.SH バグ
IPv6 拡張 API は、現在まだ RFC\ 2292 を完全には実装していない。 2.2
カーネルは受信オプションをほぼ完全にサポートサポートしているが、 glibc2.1 には IPv6 オプションを生成するマクロが存在していない。
.PP
EH および AH ヘッダ での IPSec のサポートは存在しない。
.PP
フローラベル管理はまだ完全でなく、ここにも記述されていない。
.PP
この man ページはまだ完成していない。
.SH 関連項目
\fBcmsg\fP(3), \fBip\fP(7)
.PP
RFC\ 2553: IPv6 BASIC API.  Linux はこの RFC に準拠するようにしている。
.PP
RFC\ 2460: IPv6 specification.
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
