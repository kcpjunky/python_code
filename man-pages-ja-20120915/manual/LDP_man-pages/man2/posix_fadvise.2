.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright 2003 Abhijit Menon-Sen <ams@wiw.org>
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 2005-04-08 mtk, noted kernel version and added BUGS
.\" 2010-10-09, mtk, document arm_fadvise64_64()
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH POSIX_FADVISE 2 2010\-10\-09 Linux "Linux Programmer's Manual"
.SH 名前
posix_fadvise \- ファイルデータのアクセスパターンをあらかじめ宣言する
.SH 書式
.nf
\fB#include <fcntl.h>\fP
.sp
\fBint posix_fadvise(int \fP\fIfd\fP\fB, off_t \fP\fIoffset\fP\fB, off_t \fP\fIlen\fP\fB, int \fP\fIadvice\fP\fB);\fP
.fi
.sp
.ad l
.in -4n
glibc 向けの機能検査マクロの要件 (\fBfeature_test_macros\fP(7)  参照):
.in
.sp
\fBposix_fadvise\fP():
.RS 4
_XOPEN_SOURCE\ >=\ 600 || _POSIX_C_SOURCE\ >=\ 200112L
.RE
.ad
.SH 説明
プログラムは、将来特定のパターンでファイルデータに アクセスする意思を伝えるために \fBposix_fadvise\fP()  を使うことができる。
これにより、カーネルが適切な最適化を実行することが可能になる。

\fIadvice\fP は \fIfd\fP が参照しているファイルの \fIoffset\fP から始まる \fIlen\fP バイ
トの範囲内 (\fIlen\fP が 0 の場合はファイルの終りまで) の (必ずしも存在しない)
領域に適用される。 \fIadvice\fP は義務づけではない。 \fIadvice\fP は単にアプリケー
ションのために可能性を構成するだけである。

\fIadvice\fP に許される値には、以下のものが含まれる:
.TP 
\fBPOSIX_FADV_NORMAL\fP
指定されたデータのアクセスパターンを指示するアドバイスを アプリケーションが何も持っていないことを示す。
オープンされたファイルにアドバイスが指定されない場合、 これがデフォルトで仮定される。
.TP 
\fBPOSIX_FADV_SEQUENTIAL\fP
アプリケーションは指定されたデータがシーケンシャルに (大きなオフセットの前に小さなオフセットのデータを読むように)  アクセスされることを期待する。
.TP 
\fBPOSIX_FADV_RANDOM\fP
指定されたデータがランダムな順番でアクセスされる。
.TP 
\fBPOSIX_FADV_NOREUSE\fP
指定されたデータは 1 度しかアクセスされない。
.TP 
\fBPOSIX_FADV_WILLNEED\fP
指定されたデータは近い将来アクセスされる。
.TP 
\fBPOSIX_FADV_DONTNEED\fP
指定されたデータは近い将来アクセスされない。
.SH 返り値
成功した場合は 0 が返される。 失敗した場合はエラー番号が返される。
.SH エラー
.TP 
\fBEBADF\fP
\fIfd\fP 引き数が有効なファイルディスクリプタでない。
.TP 
\fBEINVAL\fP
無効な値が \fIadvice\fP に指定された。
.TP 
\fBESPIPE\fP
指定されたファイルディスクリプタがパイプまたは FIFO を参照している (この場合、Linux は実際には \fBEINVAL\fP を返す)。
.SH バージョン
.\" of fadvise64_64()
カーネルによるサポートは Linux 2.5.60 で最初に登場し、
対応するシステムコールは \fBfadvise64\fP() という名前である。
ライブラリによるサポートは glibc バージョン 2.2 以降で提供されており、
ラッパー関数は \fBposix_fadvise\fP() という名前である。
.SH 準拠
POSIX.1\-2001.  \fIlen\fP 引き数の型が POSIX.1\-2003 TC1 において \fIsize_t\fP から \fIoff_t\fP
に変更された点に注意すること。
.SH 注意
Linux では、\fBPOSIX_FADV_NORMAL\fP はバッキングデバイスの デフォルトサイズに先読み (readahead)
ウインドウを設定する。 \fBPOSIX_FADV_SEQUENTIAL\fP はこのサイズを 2 倍し、 \fBPOSIX_FADV_RANDOM\fP
は先読みを全く無効にする。 これらの変更はファイル全体に影響し、指定された領域のみに影響するわけではない
(しかし同じファイルに対する他のオープンファイルハンドルは影響を受けない)。

\fBPOSIX_FADV_WILLNEED\fP は、 ページキャッシュに指定領域のブロックされない読み込みを開始する。 読み込まれるデータの総量は、
仮想メモリの負荷に依ってカーネルが減らすかもしれない (数メガバイトであれば通常は全く十分であり、 それより多くてもめったに役に立たない)。

2.6.18 より前のカーネルでは、\fBPOSIX_FADV_NOREUSE\fP は \fBPOSIX_FADV_WILLNEED\fP と同じ意味であった。
これは多分バグであった。 カーネル 2.6.18 以降では、このフラグは何も行わない。

\fBPOSIX_FADV_DONTNEED\fP は指定された領域に関連付けられた キャッシュページを解放しようとする。
例えば、これは大きなファイルをストリーミングするときに役立つ。 プログラムは、使用済みのキャッシュされたデータを解放するように、
定期的にカーネルに要求するかもしれない。 そうすることにより、さらに有効なキャッシュされたページが、 代わりに破棄されることはない。

まだ書き出されていないページは影響を受けないので、 そのページの解放が保証されることをアプリケーションが望んでいるなら、 最初に \fBfsync\fP(2)
または \fBfdatasync\fP(2)  を呼ぶべきである。
.SS arm_fadvise()
ARM アーキテクチャでは、64 ビットの引き数は適切なレジスタの組に割り当て
る必要がある。このアーキテクチャでは、\fBposix_fadvise\fP() の呼び出し方に
は欠陥があり、それはこのシステムコールでは引き数 \fIfd\fP と \fIlen\fP の間の
パディング (詰めもの) でレジスタが一つ消費されてしまうというものである。
そのため、Linux 2.6.14 以降では、ARM では引き数が適切な順序になった別の
システムコールが定義されている。
.PP
.in +4n
.nf
\fBlong arm_fadvise64_64(int \fP\fIfd\fP\fB, int \fP\fIadvice\fP\fB,\fP
\fB                      loff_t \fP\fIoffset\fP\fB, loff_t \fP\fIlen\fP\fB);\fP
.fi
.in
.PP
.\" No ARM support in glibc.
上記の点以外は、このシステムコールの動作は \fBposix_fadvise\fP() と全く
同じである。このシステムコールに対するライブラリによるサポートは glibc
では提供されていない。
.SH バグ
2.6.6 より前のカーネルでは、 \fIlen\fP に 0 が指定された場合、 「ファイルの終りまでの全てのバイト」という意味ではなく、 文字通り「0
バイト」として解釈されていた。
.SH 関連項目
.\" FIXME . Write a posix_fadvise(3) page.
\fBreadahead\fP(2), \fBsync_file_range\fP(2), \fBposix_fallocate\fP(3),
\fBposix_madvise\fP(3)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
