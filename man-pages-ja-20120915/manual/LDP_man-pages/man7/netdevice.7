.\" t
.\" Don't change the first line, it tells man that tbl is needed.
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: netdevice.7,v 1.10 2000/08/17 10:09:54 ak Exp $
.\"
.\" Modified, 2004-11-25, mtk, formatting and a few wording fixes
.\"
.\" Modified, 2011-11-02, <bidulock@openss7.org>, added many basic
.\"  but missing ioctls, such as SIOCGIFADDR.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH NETDEVICE 7 2012\-04\-26 Linux "Linux Programmer's Manual"
.SH 名前
netdevice \- Linux ネットワークデバイスへの低レベルアクセス
.SH 書式
\fB#include <sys/ioctl.h>\fP
.br
\fB#include <net/if.h>\fP
.SH 説明
この man ページでは、ネットワークデバイスを設定するために 用いるソケットインターフェースについて解説する。

Linux はネットワークデバイスを設定するための標準的な ioctl を いくつか備えている。これらはどんなソケットのファイルディスクリプタにも
用いることができる。ファミリーやタイプは何でもよい。 これらの ioctl は \fIifreq\fP 構造体を渡す。

.in +4n
.nf
struct ifreq {
    char ifr_name[IFNAMSIZ]; /* Interface name */
    union {
        struct sockaddr ifr_addr;
        struct sockaddr ifr_dstaddr;
        struct sockaddr ifr_broadaddr;
        struct sockaddr ifr_netmask;
        struct sockaddr ifr_hwaddr;
        short           ifr_flags;
        int             ifr_ifindex;
        int             ifr_metric;
        int             ifr_mtu;
        struct ifmap    ifr_map;
        char            ifr_slave[IFNAMSIZ];
        char            ifr_newname[IFNAMSIZ];
        char           *ifr_data;
    };
};

struct ifconf {
    int                 ifc_len; /* size of buffer */
    union {
        char           *ifc_buf; /* buffer address */
        struct ifreq   *ifc_req; /* array of structures */
    };
};
.fi
.in

通常、ユーザーによる設定対象デバイスの指定は、 \fIifr_name\fP にインターフェースの名前をセットすることによって行う。
他の構造体の全てのメンバは、メモリを共有する。
.SS ioctl
「特権が必要」と記述されている ioctl を実行するには、 実効ユーザー ID が 0 か、 \fBCAP_NET_ADMIN\fP
権限が必要である。これが満たされていない場合は \fBEPERM\fP が返される。
.TP 
\fBSIOCGIFNAME\fP
\fIifr_ifindex\fP を受け取り、インターフェースの名前を \fIifr_name\fP に入れて返す。これは結果を \fIifr_name\fP
として返す唯一の ioctl である。
.TP 
\fBSIOCGIFINDEX\fP
インターフェースの interface index を取得し、 \fIifr_ifindex\fP に入れて返す。
.TP 
\fBSIOCGIFFLAGS\fP, \fBSIOCSIFFLAGS\fP
デバイスの active フラグワードを取得または設定する。 \fIifr_flags\fP には以下の値のビットマスクが入る。
.TS
tab(:);
c s
l l.
デバイスフラグ
IFF_UP:インターフェースは動作中。
IFF_BROADCAST:有効なブロードキャストアドレスがセットされている。
IFF_DEBUG:内部のデバッグフラグ。
IFF_LOOPBACK:インターフェースはループバックである。
IFF_POINTOPOINT:インターフェースは point\-to\-point リンクである。
IFF_RUNNING:リソースが割り当て済み。
IFF_NOARP:arp プロトコルがない。
IFF_PROMISC:インターフェースは promiscuous モードである。
IFF_NOTRAILERS:trailer の利用を避ける。
IFF_ALLMULTI:全てのマルチキャストパケットを受信する。
IFF_MASTER:負荷分散グループのマスターである。
IFF_SLAVE:負荷分散グループのスレーブである。
IFF_MULTICAST:マルチキャストをサポートしている。
IFF_PORTSEL:ifmap によってメディアタイプを選択できる。
IFF_AUTOMEDIA:自動メディア選択が有効になっている。
IFF_DYNAMIC:T{
このインターフェースが閉じると、アドレスは失われる。
T}
IFF_LOWER_UP:ドライバからの L1 アップの通知 (Linux 2.6.17 以降)
IFF_DORMANT:ドライバからの休止状態の通知 (Linux 2.6.17 以降)
IFF_ECHO:送られたパケットをエコーする (Linux 2.6.25 以降)


.TE
active フラグワードの設定は特権が必要な操作である。
読み出しはどんなプロセスからも可能である。
.TP 
\fBSIOCGIFPFLAGS\fP, \fBSIOCSIFPFLAGS\fP
デバイスの拡張 (プライベート) フラグを取得または設定する。
\fIifr_flags\fP には以下の値のビットマスクが入る。
.TS
tab(:);
c s
l l.
プライベートフラグ
IFF_802_1Q_VLAN:インターフェースは 802.1Q VLAN デバイスである。
IFF_EBRIDGE:インターフェースは Ethernet ブリッジデバイスである。
IFF_SLAVE_INACTIVE:インターフェースは非アクティブな bonding のスレーブである。
IFF_MASTER_8023AD:インターフェースは 802.3ad bonding のマスターである。
IFF_MASTER_ALB:インターフェースは balanced\-alb bonding のマスターである。
IFF_BONDING:インターフェースは bonding のマスターかスレーブである。
IFF_SLAVE_NEEDARP:インターフェースは検証に APR が必要である。
IFF_ISATAP:インターフェースは RFC4214 ISATAP インターフェースである。
.TE
.sp
拡張 (プライベート) インターフェースフラグの設定には特権が必要である。
.TP 
\fBSIOCGIFADDR\fP, \fBSIOCSIFADDR\fP
\fIifr_addr\fP を用いてデバイスのアドレスの設定/取得を行う。
インターフェースのアドレスの設定は特権が必要な操作である。
互換性確保のため、設定/取得ができるのは \fBAF_INET\fP アドレスだけである。
.TP 
\fBSIOCGIFDSTADDR\fP, \fBSIOCSIFDSTADDR\fP
point\-to\-point デバイスの宛先アドレスを \fIifr_dstaddr\fP を用いて
設定/取得する。互換性確保のため、
設定/取得ができるのは \fBAF_INET\fP アドレスだけである。
宛先アドレスの設定は特権が必要な操作である。
.TP 
\fBSIOCGIFBRDADDR\fP, \fBSIOCSIFBRDADDR\fP
デバイスのブロードキャストアドレスを \fIifr_brdaddr\fP を用いて
設定/取得する。互換性確保のため、
設定/取得ができるのは \fBAF_INET\fP アドレスだけである。
ブロードキャストアドレスの設定は特権が必要な操作である。
.TP 
\fBSIOCGIFNETMASK\fP, \fBSIOCSIFNETMASK\fP
デバイスのネットワークマスクを \fIifr_netmask\fP を用いて
設定/取得する。互換性確保のため、
設定/取得ができるのは \fBAF_INET\fP アドレスだけである。
ネットワークマスクの設定は特権が必要な操作である。
.TP 
\fBSIOCGIFMETRIC\fP, \fBSIOCSIFMETRIC\fP
デバイスのメトリックを \fIifr_metric\fP を用いて取得・設定する。 これはまだ実装されていない。読み出そうとすると \fIifr_metric\fP
に 0 をセットして返り、設定しようとすると \fBEOPNOTSUPP\fP が返る。
.TP 
\fBSIOCGIFMTU\fP, \fBSIOCSIFMTU\fP
デバイスの MTU (Maximum Transfer Unit) を \fIifr_mtu\fP を用いて取得・設定する。 MTU
の設定は特権が必要な操作である。 MTU の値を小さくしすぎるとカーネルがクラッシュするかもしれない。
.TP 
\fBSIOCGIFHWADDR\fP, \fBSIOCSIFHWADDR\fP
デバイスのハードウェアアドレスを \fIifr_hwaddr\fP を用いて取得・設定する。 ハードウェアアドレスは \fIsockaddr\fP
構造体に設定される。 \fIsa_family\fP には ARPHRD_* デバイスタイプが入り、 \fIsa_data\fP にはバイト 0 から始まる L2
ハードウェアアドレスが入る。 ハードウェアアドレスの設定は特権が必要な操作である。
.TP 
\fBSIOCSIFHWBROADCAST\fP
デバイスのハードウェアブロードキャストアドレスを \fIifr_hwaddr\fP の値に設定する。この操作には特権が必要である。
.TP 
\fBSIOCGIFMAP\fP, \fBSIOCSIFMAP\fP
インターフェースのハードウェアのパラメータを \fIifr_map\fP を用いて取得・設定する。 パラメータの設定は特権が必要な操作である。

.in +4n
.nf
struct ifmap {
    unsigned long   mem_start;
    unsigned long   mem_end;
    unsigned short  base_addr;
    unsigned char   irq;
    unsigned char   dma;
    unsigned char   port;
};
.fi
.in

ifmap 構造体の解釈はデバイスドライバとアーキテクチャに依存する。
.TP 
\fBSIOCADDMULTI\fP, \fBSIOCDELMULTI\fP
デバイスのリンク層のマルチキャストフィルターから、 \fIifr_hwaddr\fP のアドレスを追加・削除する。これらの操作には特権が必要である。
別の方法が \fBpacket\fP(7)  で解説されている。
.TP 
\fBSIOCGIFTXQLEN\fP, \fBSIOCSIFTXQLEN\fP
デバイスの送信キューの長さを \fIifr_qlen\fP に取得・設定する。送信キューの長さの設定には特権が必要である。
.TP 
\fBSIOCSIFNAME\fP
\fIifr_name\fP で指定したインターフェースの名前を \fIifr_newname\fP に変更する。この操作には特権が必要である。インターフェースが
up していない 時にのみ使用できる。
.TP 
\fBSIOCGIFCONF\fP
.\" Slaving isn't supported in 2.2
.\" .
.\" .TP
.\" .BR SIOCGIFSLAVE ", " SIOCSIFSLAVE
.\" Get or set the slave device using
.\" .IR ifr_slave .
.\" Setting the slave device is a privileged operation.
.\" .PP
.\" FIXME add amateur radio stuff.
インターフェース(トランスポート層)アドレスのリストを返す。 現在のところ、互換性のために \fBAF_INET\fP (IPv4)
ファミリーのアドレスのみである。 ユーザーは \fIifconf\fP 構造体を ioctl の引数として渡す。 \fIifconf\fP 構造体には、
\fIifreq\fP 構造体の配列へのポインタである \fIifc_req\fP と、バイト単位の配列の長さを指定する \fIifc_len\fP が含まれる。
カーネルは ifreqs を現在動作している全ての L3 インターフェースアドレスで埋める。 \fIifr_name\fP にはインターフェース名
(eth0:1 など) が入り、 \fIifr_addr\fP にはアドレスが入る。 カーネルは実際の長さを \fIifc_len\fP に返す。
\fIifc_len\fP が元のバッファの長さと同じだった場合、 オーバーフローを起こしている可能性があるので、
全てのアドレスを取得するためにより大きなバッファで再試行するべきである。 エラーがなかった場合は ioctl は 0 を返す。 エラーがあった場合は
\-1 を返す。 オーバーフローはエラーとは見なされない。
.PP
ほとんどのプロトコルには、専用のインターフェースオプションを 設定するための独自の ioctl が存在する。 説明は各プロトコルの man
ページを見よ。
.PP
さらに、デバイスによってはプライベートな ioctl がある。 これらはここでは説明しない。
.SH 注意
厳密にいうと、 \fBSIOCGIFCONF\fP や、 \fBAF_INET\fP ソケットアドレスだけを
引き数に取ったり返したりする他の ioctl は IP 固有であり、 \fBip\fP(7)
に属する。
.LP
アドレスがなかったり、 \fBIFF_RUNNING\fP フラグがセットされていないインターフェースの名前は \fI/proc/net/dev\fP
で知ることができる。
.LP
ローカル IPV6 IP アドレスは \fI/proc/net\fP か \fBrtnetlink\fP(7)  で知ることができる。
.SH バグ
glibc 2.1 では \fI<net/if.h>\fP に \fIifr_newname\fP マクロがない。
とりあえずの対応策として、以下のコードを追加しておくこと。
.sp
.in +4n
.nf
#ifndef ifr_newname
#define ifr_newname     ifr_ifru.ifru_slave
#endif
.fi
.in
.SH 関連項目
\fBproc\fP(5), \fBcapabilities\fP(7), \fBip\fP(7), \fBrtnetlink\fP(7)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
