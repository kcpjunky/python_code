.\" Copyright (c) 2000 Andries Brouwer (aeb@cwi.nl)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GETPASS 3 2010\-09\-20 Linux "Linux Programmer's Manual"
.SH 名前
getpass \- パスワードを取得する
.SH 書式
\fB#include <unistd.h>\fP
.sp
\fBchar *getpass( const char *\fP\fIprompt\fP\fB);\fP
.sp
.in -4n
glibc 向けの機能検査マクロの要件 (\fBfeature_test_macros\fP(7)  参照):
.in
.sp
\fBgetpass\fP():
.ad l
.RS 4
.PD 0
.TP  4
glibc 2.2.2 以降:
.nf
_BSD_SOURCE ||
    (_XOPEN_SOURCE\ >=\ 500 ||
        _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
    !(_POSIX_C_SOURCE\ >=\ 200112L || _XOPEN_SOURCE\ >=\ 600)
.TP  4
.fi
glibc 2.2.2 より前: なし
.PD
.RE
.ad b
.SH 説明
この関数は obsolete である。用いないこと。
.PP
\fBgetpass\fP()  関数は \fI/dev/tty\fP (プロセスの制御端末) をオープンし、文字列 \fIprompt\fP を出力する。そして
echo をオフにし、一行 (「パスワード」)  を読み込み、端末の状態を元に戻して、再び \fI/dev/tty\fP をクローズする。
.SH 返り値
\fBgetpass\fP()  関数は入力されたパスワード (の最初の \fBPASS_MAX\fP バイトまで) が書きこまれた、
スタティックなバッファーへのポインターを返す。 末尾の改行は含まれない。この文字列は NULL バイト (\(aq\e0\(aq) で終端される。
このバッファーは、以降の関数コールで上書きされるかもしれない。 エラーが起こると、端末の状態を復元し、 \fIerrno\fP を適切な値に設定して、NULL
を返す。
.SH エラー
この関数は以下のような場合に失敗しうる。
.TP 
\fBENXIO\fP
プロセスが制御端末を持っていない。
.SH ファイル
.\" .SH HISTORY
.\" A
.\" .BR getpass ()
.\" function appeared in Version 7 AT&T UNIX.
\fI/dev/tty\fP
.SH 準拠
SUSv2 には存在するが、過去の名残 (LEGACY) と位置付けられている。 POSIX.1\-2001 で削除された。
.SH 注意
libc4 と libc5 では、 \fIprompt\fP は \fI/dev/tty\fP にではなく \fIstderr\fP に出力された。さらに、
\fI/dev/tty\fP がオープンできない場合は、パスワードは \fIstdin\fP から読み込まれた。 スタティックなバッファーの長さは 128
バイトだったので、 パスワードの最初の 127 文字だけが返された。 パスワードを読んでいる途中には、シグナルの発行 (\fBSIGINT\fP,
\fBSIGQUIT\fP, \fBSIGSTOP\fP, \fBSIGSTOP\fP)  は無効にされ、 それぞれに対応する文字 (通常は Ctrl\-C,
Ctrl\-\e, Ctrl\-Z, Ctrl\-Y)  はそのままパスワードの一部として渡された。 libc 5.4.19 からは行編集が無効にされ、
したがってバックスペースなどもパスワードの一部とみなされるようになった。
.PP
glibc2 では、 \fI/dev/tty\fP がオープンできない場合は \fIprompt\fP は \fIstderr\fP に書き出され、パスワードは
\fIstdin\fP から読み込まれた。 パスワードの長さには制限はなく、 行編集も無効にはされなかった。
.PP
SUSv2 によれば、 \fBPASS_MAX\fP の値が 8 以下の場合は、この値は \fI<limits.h>\fP
で定義されていなければならない。 いずれの場合でもこの値は \fIsysconf(_SC_PASS_MAX)\fP によって取得できる。
しかし、POSIX.2 は定数 \fBPASS_MAX\fP, \fB_SC_PASS_MAX\fP と関数 \fBgetpass\fP()  を取り下げた。 libc4
と libc5 では、 \fBPASS_MAX\fP と \fB_SC_PASS_MAX\fP は一度もサポートされたことはない。 glibc2 は
\fB_SC_PASS_MAX\fP を受付け、 \fBBUFSIZE\fP (例えば 8192) を返す。
.SH バグ
この関数を呼び出したプロセスは、 できる限り早くそのパスワードを消去 (ゼロクリア) し、 クリアテキストのパスワードが
そのプロセスのアドレス空間で見えないようにすべきである。
.SH 関連項目
\fBcrypt\fP(3)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
