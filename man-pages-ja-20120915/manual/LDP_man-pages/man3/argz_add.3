.\" Copyright 2002 walter harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\" based on the description in glibc source and infopages
.\"
.\" Corrections and additions, aeb
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH ARGZ_ADD 3 2007\-05\-18 "" "Linux Programmer's Manual"
.SH 名前
argz_add, argz_add_sep, argz_append, argz_count, argz_create,
argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next,
argz_replace, argz_stringify \- argz リストを操作するための関数群
.SH 書式
.nf
\fB#include <argz.h>\fP
.sp
\fBerror_t argz_add(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB);\fP
.sp
\fBerror_t argz_add_sep(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIstr\fP\fB, int \fP\fIdelim\fP\fB);\fP
.sp
\fBerror_t argz_append(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIbuf\fP\fB, size_t \fP\fIbuf_len\fP\fB);\fP
.sp
\fBsize_t argz_count(const char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create(char * const \fP\fIargv\fP\fB[], char **\fP\fIargz\fP\fB,\fP
.ti 20n
\fBsize_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create_sep(const char *\fP\fIstr\fP\fB, int \fP\fIsep\fP\fB, char **\fP\fIargz\fP\fB,\fP
.ti 20n
\fBsize_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_delete(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIentry\fP\fB);\fP
.sp
\fBvoid argz_extract(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, char  **\fP\fIargv\fP\fB);\fP
.sp
\fBerror_t argz_insert(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIbefore\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIentry\fP\fB);\fP
.sp
\fBchar *argz_next(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, const char *\fP\fIentry\fP\fB);\fP
.sp
\fBerror_t argz_replace(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIwith\fP\fB, unsigned int *\fP\fIreplace_count\fP\fB);\fP
.sp
\fBvoid argz_stringify(char *\fP\fIargz\fP\fB, size_t \fP\fIlen\fP\fB, int \fP\fIsep\fP\fB);\fP
.fi
.SH 説明
これらの関数は glibc 固有である。
.LP
argz vector は長さ情報付きの文字バッファへのポインタである。 文字バッファでは、複数の文字列が NULL バイト
(\e(aq\e0\e(aq) で区切られており、 文字列の配列として解釈されるようになっている。 長さが 0 でない場合、バッファの最後のバイトは
NULL バイトでなければならない。
.LP
これらの関数は argz vector を操作するためのものである。 ペア (NULL,0) は argz vector であり、逆に言えば 長さ 0
の argz vectorは NULL ポインタを持たなければならない。 空でない argz vector の割り当ては \fBmalloc\fP(3)
を使って行われる。したがって、argz vector を解放するのに \fBfree\fP(3)  を使うことができる。
.LP
\fBargz_add\fP()  は、文字列 \fIstr\fP を配列 \fI*argz\fP の末尾に追加し、 \fI*argz\fP と \fI*argz_len\fP
を更新する。
.LP
\fBargz_add_sep\fP()  も同様の動作をするが、区切り文字 \fIdelim\fP にしたがって文字列 \fIstr\fP
を複数の文字列に分割する点が異なる。 例えば、区切り文字 \e(aq:\e(aq を指定して、UNIX サーチ・パスに対して
この関数を使うことができるだろう。
.LP
\fBargz_append\fP()  は argz vector (\fIbuf\fP,\ \fIbuf_len\fP)  の後ろに (*\fIargz\fP,\ \fI*argz_len\fP)  を付け加え、 \fI*argz\fP と \fI*argz_len\fP を更新する。 (したがって、 \fI*argz_len\fP は
\fIbuf_len\fP だけ増加する。)
.LP
\fBargz_count\fP()  は (\fIargz\fP,\ \fIargz_len\fP)  内の文字列の数を数える。実際には NULL バイト
(\e(aq\e0\e(aq) の数を数えている。
.LP
\fBargz_create\fP()  は、UNIX 流の引き数ベクトルである (\fI(char *) 0\fP で終端される)  \fIargv\fP を、argz
vector (\fI*argz\fP,\ \fI*argz_len\fP)  に変換する。
.LP
\fBargz_create_sep\fP()  は、NULL 終端された文字列 \fIstr\fP を区切り文字 \fIsep\fP が現れる毎に分割しながら、argz
vector (*\fIargz\fP,\ \fI*argz_len\fP)  に変換する。
.LP
\fBargz_delete\fP()  は、 \fIentry\fP で指し示された文字列を argz vector (\fI*argz\fP,\ \fI*argz_len\fP)  から削除し、 \fI*argz\fP と \fI*argz_len\fP を更新する。
.LP
\fBargz_extract\fP()  は \fBargz_create\fP()  の反対の操作を行う。argz vector (\fIargz\fP,\ \fIargz_len\fP)  を調べ、 \fIargv\fP から始まる配列をサブ文字列へのポインタで埋めていき、 一番最後に NULL を入れて、UNIX
流の argv ベクトルを作成する。 配列 \fIargv\fP は \fIargz_count\fP(\fIargz\fP,\fIargz_len\fP) + 1
個のポインタを収容できる空間を持っていなければならない。
.LP
\fBargz_insert\fP()  は \fBargz_delete\fP()  の反対の操作を行う。argz vector (\fI*argz\fP,\ \fI*argz_len\fP)  の位置 \fIbefore\fP に引き数 \fIentry\fP を挿入し、 \fI*argz\fP と \fI*argz_len\fP
を更新する。 \fIbefore\fP が NULL の場合、 \fIentry\fP は末尾に挿入される。
.LP
\fBargz_next\fP()  は argz vector を順番に調べるための関数である。 \fIentry\fP が NULL
の場合、最初のエントリを返す。 そうでない場合、次のエントリを返す。 次のエントリがない場合、NULL を返す。
.LP
\fBargz_replace\fP()  は、 \fIstr\fP をすべて \fIwith\fP で置き換える (必要に応じて argz の再割り当てを行う)。
\fIreplace_count\fP が NULL でない場合、 \fI*replace_count\fP を置き換えを行った数だけ増やす。
.LP
\fBargz_stringify\fP()  は \fBargz_create_sep\fP()  の反対の操作を行う。 末尾の NULL バイト以外の全ての
NULL バイト (\e(aq\e0\e(aq) を \fIsep\fP で置き換えて、 argz vector を通常の文字列に変換する。
.SH 返り値
メモリ割り当てを行う argz 関数群はすべて \fIerror_t\fP 型の返り値を持つ。 成功した場合は 0 を返し、割り当てエラーが発生した場合は
\fBENOMEM\fP を返す。
.SH 準拠
これらの関数は GNU による拡張である。注意して使用すること。
.SH バグ
NULL バイトで終端されていない argz vector を使用した場合、 segmentation fault を起こすかもしれない。
.SH 関連項目
\fBenvz_add\fP(3)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.41 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。
